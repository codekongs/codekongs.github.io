<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码控</title>
  
  <subtitle>夫唯不争,故莫能与之争</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codekong.cn/"/>
  <updated>2018-09-01T02:42:35.816Z</updated>
  <id>http://www.codekong.cn/</id>
  
  <author>
    <name>冰鉴IT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin系列之Lambda表达式(3)</title>
    <link href="http://www.codekong.cn/2018/09/01/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-3/"/>
    <id>http://www.codekong.cn/2018/09/01/Kotlin系列之Lambda表达式-3/</id>
    <published>2018-09-01T02:38:24.000Z</published>
    <updated>2018-09-01T02:42:35.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天一起来看看Kotlin中与Lambda相关的成员引用的内容。</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先说说什么是成员引用，这里的引用指的就是变量引用，就相当于Java中的引用概念。成员的概念这里包含了成员变量和成员方法。这都是很官方的的说法。说白了，就是类里面的变量和函数。所以我们这篇文章讨论的就是如果一个成员函数或者变量已经被定义好了，我们如何使用Lambda表达式的语法，将它传递给另一个函数。</p><h4 id="成员引用语法"><a href="#成员引用语法" class="headerlink" title="成员引用语法"></a>成员引用语法</h4><p>我们的成员引用遵循下面的语法。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">类名::</span>成员变量名</span><br><span class="line"><span class="symbol">类名::</span>成员方法名</span><br></pre></td></tr></table></figure></p><p>这里通过<code>::</code>这个运算符负责将一个成员转化成一个值。</p><h5 id="一般类的成员引用"><a href="#一般类的成员引用" class="headerlink" title="一般类的成员引用"></a>一般类的成员引用</h5><p>我们按照上面的语法来写一个一般类的成员引用的例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"do something"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> age = Person::age</span><br><span class="line">    <span class="keyword">val</span> doFun = Person::doSomething</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    doFun(p)</span><br><span class="line">    println(age(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子虽然有点繁琐，但重点是为了演示这种用法。而且要注意一点，上面的成员方法的引用<code>::</code>之后只有方法名，没有<code>()</code>。<br>当然成员引用也可以写成下面这样，这样看起来更清晰好理解一点。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    <span class="keyword">val</span> getAge = &#123;p1: Person -&gt; p1.age&#125;</span><br><span class="line">    getAge(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="引用顶层函数"><a href="#引用顶层函数" class="headerlink" title="引用顶层函数"></a>引用顶层函数</h5><p>上面的引用都是要依托于类名，但是顶层函数是不依附于某个类的，那在Lambda表达式中该怎样引用呢？<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span>  <span class="title">printInfo</span><span class="params">()</span></span> = println(<span class="string">"Info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printFun = ::printInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到引用方式是直接省略了类名，通过<code>::方法名</code>就可以引用了。</p><h5 id="引用构造函数"><a href="#引用构造函数" class="headerlink" title="引用构造函数"></a>引用构造函数</h5><p>下面在说说Lambda中如何引用构造函数，我们知道我们调用构造函数就创建了一个对象，那如果我把构造函数的引用赋值给一个变量，就可以对构造函数进行存储和传递，然后在需要创建对象的时候再去创建。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> createUser = ::User</span><br><span class="line">    <span class="keyword">val</span> user = createUser(<span class="string">"cmq"</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的使用方式为<code>::类名</code>，跟顶层函数的应用有点像，看上面的例子就好像给构造函数起了个别名，但它却是可以被传递的。</p><h5 id="引用扩展函数"><a href="#引用扩展函数" class="headerlink" title="引用扩展函数"></a>引用扩展函数</h5><p>我们在前面还说过扩展函数，那么在Lambda中如何引用扩展函数呢。其实扩展函数可以看作是被扩展的类的成员函数，所以引用方式和一般类的成员引用是一样的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">isOld</span><span class="params">()</span></span> = age &gt; <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> siOldFun = User::isOld</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>今天的内容就结束了，总结为一句话就是我们知道了如何将成员函数和属性变成可以传递的参数，上面的内容基本覆盖了常用的场景，又一次看到了Kotlin的简洁。</p>]]></content>
    
    <summary type="html">
    
      “今天学习一下Kotlin中Lambda表达式第三部分。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之Lambda表达式(2)</title>
    <link href="http://www.codekong.cn/2018/07/29/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/"/>
    <id>http://www.codekong.cn/2018/07/29/Kotlin系列之Lambda表达式-2/</id>
    <published>2018-07-29T09:47:55.000Z</published>
    <updated>2018-07-29T09:53:09.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇文章讲到了最基本的Lambda表达式，今天这篇文章继续讲Lambda表达式中的在作用域中访问变量。</p></blockquote><h5 id="Java中的内部类访问变量"><a href="#Java中的内部类访问变量" class="headerlink" title="Java中的内部类访问变量"></a>Java中的内部类访问变量</h5><p>当我们在函数内部使用匿名内部类时，我们可以在匿名内部类内使用函数的参数和函数内的局部变量。当我们在使用Lambda表达式时，我们也可以访问这个函数的参数和使用那些在Lambda表达式之前定义的变量。</p><p>下面先看一个在Java中匿名内部类中访问函数参数和局部变量的例子。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> search() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"xxxx"</span>;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的这个例子中局部变量<strong>str</strong>在匿名内部类中被使用，所以必须要加final修饰符。</p><p>如果你使用的JDK是Java8版本，那你会发现你不写final修饰符也是不会报错的。这因为Java8中final修饰符不是必需的，但是如果你尝试在内部类中更改str的值，IDE就会告诉你，在匿名内部类中使用的局部变量是final的，不可以被修改。所以在Java8中如果你没有尝试去修改那个值，final修饰符是可以省略的。</p><p>那为什么在Java中匿名内部类中使用的变量必须是final类型呢？这里涉及到一个作用域的问题。str多的作用域是search()这个函数，函数运行结束，那这个局部变量就消失了，但是我们的匿名内部类的执行时机并不是在search()函数执行完成前，可能search()函数已经结束了，匿名内部类线程才会执行，如果这时候str不是final类型，它就已经被回收了，当线程类执行的时候就会找不到这个变量而报错。如果使用final修饰符，Java就会复制一份这个变量作为内部类的成员变量，由于是final修饰的，还保证了这份复制过来的变量不会被篡改，使内部类和外部类的变量保持一致性。</p><h5 id="Kotlin在作用域中访问变量"><a href="#Kotlin在作用域中访问变量" class="headerlink" title="Kotlin在作用域中访问变量"></a>Kotlin在作用域中访问变量</h5><p>上面解释了Java中匿名内部类中变量访问的情况及原理，其实把上面的匿名内部类换成Lambda表达式也可以做同样的事，达到同样的效果。<br>那下面看看在Kotlin中使用Lambda表达式访问作用域中的变量的规则。</p><p>在Kotlin中在Lambda表达式内部可以访问外部的变量，而无需声明为final，而且在Lambda内部可以修改这些变量。下面看一个示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countThings</span><span class="params">(datas : <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    datas.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>)&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"count = <span class="variable">$count</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码forEach里面传递的就是一个Lambda表达式，对于局部变量count并没有被声明为final，同时这个变量还可以在Lambda表达式内部被修改。</p><p>与Java比起来这是不是有点不可思议，那Kotlin是怎么做到的。</p><p>在分析之前我们先来看一下，加入我们在Java中是如何实现匿名内部类中修改外部变量的值的。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> search() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span>[] <span class="built_in">str</span> = &#123;<span class="string">"xxxx"</span>&#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">0</span>] = <span class="built_in">str</span>[<span class="number">0</span>] + <span class="string">"|"</span> + i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="built_in">str</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中Java为了让我们让匿名内部类可以修改外部的变量，我们创建了一个单元素的数组，并声明为final类型。这样虽然str数组是final的，但它其中的元素却是可以修改的，这样就既保证了匿名内部类从函数中复制到匿名内部类内部的变量是不可变的，又保证了我们可以在匿名内部类中修改这个变量值。</p><p>Java除了使用上面的方法解决这个问题外，还有一种方法如下<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void search<span class="literal">()</span> &#123;</span><br><span class="line">    final <span class="type">Ref</span>&lt;<span class="type">String</span>&gt; <span class="built_in">ref</span> = <span class="keyword">new</span> <span class="type">Ref</span>&lt;&gt;(<span class="string">"xxxx"</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="literal">()</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">ref</span>.<span class="keyword">value</span>= <span class="built_in">ref</span>.<span class="keyword">value</span> + <span class="string">"|"</span> + i;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="built_in">ref</span>.<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static <span class="keyword">class</span> <span class="type">Ref</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line">    <span class="type">T</span> <span class="keyword">value</span>;</span><br><span class="line">    public  <span class="type">Ref</span>(<span class="type">T</span> <span class="keyword">value</span>)&#123;</span><br><span class="line">        this.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中我们使用了一个静态内部类，虽然静态内部类的引用是final类型的，但我们却可以修改它内部的value属性，也就达到了在Lambda表达式中修改外部变量的目的。</p><p>其实上面的这种方法，正是Kotlin使用的方法。Kotlin内部就是通过这样的方法使我们可以在Lambda内部修改外部的变量。只是不需要我们显式去创建这样的包装器类。</p><p>所以用专业一点的术语解释就是，默认情况下，局部变量的声明周期是被限制在了声明这个变量的函数中，但是如果它在Lambda内部被使用了，我们就称它被Lambda捕获了，这时候，使用这个变量的代码就会被存储并稍后执行。当捕获了一个final变量时，它的值就会和使用这个值的Lambda表达式一起被存储，如果对非final变量，它的值就像上面演示的一样被封装在一个包装器内部，这样这个值就可以被改变，同时会被这个包装器类的引用和Lambda代码一起存储。</p><p>说白了，就是如果你只是在Lambda内部使用这个值而不修改它，那就复制一份它的值到Lambda表达式内部，如果你在Lambda内部使用它，那Kotlin就会创建一个包装器类，同时把这个包装器类的引用复制到Lambda表达式内部方便你修改它。</p><h5 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h5><p>本节涉及到的这个只是点还是蛮重要的，但是Kotlin已经帮我们隐藏了背后的实现细节，但我觉得背后的原因还是有必要搞清楚的。</p>]]></content>
    
    <summary type="html">
    
      “今天学习一下Kotlin中Lambda表达式第二部分。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之Lambda表达式(1)</title>
    <link href="http://www.codekong.cn/2018/07/10/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/"/>
    <id>http://www.codekong.cn/2018/07/10/Kotlin系列之Lambda表达式-1/</id>
    <published>2018-07-10T14:35:29.000Z</published>
    <updated>2018-07-10T17:18:39.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天开始后续的几篇Kotlin的文章会介绍Kotlin中Lambda表达式相关的内容。</p></blockquote><h3 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h3><p>在Java8中引入了Lambda表达式，这是最令Java开发者激动和期待的一个功能。那究竟什么是Lambda表达式呢？</p><p>Lambda表达式本质上是可以传递给其他函数的一小段代码，我们在之前的Java或者Kotlin中，一个函数的参数可以是一种简单的基本数据类型变量或一个对象实例变量。Lambda表达式的出现可以让我们可以把一段代码当做一个值来进行对待，由于是值，便可以进行传递，所以Lambda可以被当做参数传递给其他函数。Lambda表达式的出现，让我们的代码更加简洁。</p><h3 id="Kotlin中的Lambda表达式"><a href="#Kotlin中的Lambda表达式" class="headerlink" title="Kotlin中的Lambda表达式"></a>Kotlin中的Lambda表达式</h3><p>上面的文字描述可能比较抽象，我们举一个实际的例子。我们定义一个数据类人(对于Kotlin数据类不了解的可以查看这篇文章<a href="http://www.codekong.cn/2018/03/06/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%A7%94%E6%89%98/">Kotlin系列之数据类和类委托</a>)。我们的目的是找出一堆人中年龄最大的那个人。</p><p>我们先用最基础的Kotlin知识来解决上述问题。代码示例如下:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findTheOldest</span><span class="params">(peopleList: <span class="type">List</span>&lt;<span class="type">People</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxAge = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> theOldestPeople: People? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (people <span class="keyword">in</span> peopleList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people.age &gt; maxAge) &#123;</span><br><span class="line">            maxAge = people.age</span><br><span class="line">            theOldestPeople = people</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(theOldestPeople)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleList = listOf&lt;People&gt;(People(<span class="string">"小白"</span>, <span class="number">22</span>),</span><br><span class="line">            People(<span class="string">"小红"</span>, <span class="number">23</span>), People(<span class="string">"琦琦"</span>, <span class="number">20</span>))</span><br><span class="line">    findTheOldest(peopleList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是Kotlin中可以使用库函数配合Lambda将代码进行大大的简化，我们先看看可以最终可以简化到何种程度。代码如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleList = listOf&lt;People&gt;(People(<span class="string">"小白"</span>, <span class="number">22</span>),</span><br><span class="line">            People(<span class="string">"小红"</span>, <span class="number">23</span>), People(<span class="string">"琦琦"</span>, <span class="number">20</span>))</span><br><span class="line">    <span class="comment">//关键代码就这一行</span></span><br><span class="line">    println(peopleList.maxBy &#123; it.age &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是被惊艳到了，代码量大大大大减少了，而且代码所表达的功能也更加清楚了。下面我们就来看看上面的那么多代码是怎么利用Lambda表达式变成一行代码的。</p><h3 id="Lambda表达式的简化过程"><a href="#Lambda表达式的简化过程" class="headerlink" title="Lambda表达式的简化过程"></a>Lambda表达式的简化过程</h3><p>下面就来看看具体的演变过程。<br>首先<strong>maxBy</strong>这个函数式类似于一个比较器，它不关心具体的集合中的元素是什么类型，只需要我们传入比较的规则即可，我们上面比较的规则是人们的年龄。所以我们可以把比较规则使用Lambda来书写传入maxBy函数中。</p><p>首先先让我们看看Lambda表达式的语法。一个Lambda表达式的基本结构是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数1: 类型, 参数2: 类型, [...] -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>可以看出，一个Lambda表达式被一个花括号包围，参数并没有是哟圆括号括起来，参数列表和函数体之间使用箭头进行分隔。</p><p>所以我们依据上面的格式要求，会写出下面这样的代码:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.maxBy(&#123;p: People -&gt; p.age&#125;)</span><br></pre></td></tr></table></figure><p>上面是最原始的Lambda表达式代码。</p><p>根据Kotlin的语法约定: <strong>如果Lambda表达式是函数调用的最后一个实参,它可以放在括号的外面。</strong><br>由于在这个例子中Lambda表达式是maxBy函数的唯一实参，也自然是最后一个实参，所以代码就变成下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.maxBy()&#123;p: People -&gt; p.age&#125;</span><br></pre></td></tr></table></figure></p><p>但是要记住，当函数有多个实参时，我们既可以将Lambda表达式留在括号内，也可以放在括号的外面，但当我们传递的是两个或更多个Lambda表达式时，不能把超过一个的Lambda表达式放在括号外面。</p><p>根据Kotlin的语法约定: <strong>如果Lambda表达式是函数的唯一实参,可以去掉空的圆括号对。</strong><br>所以上面的代码又会进一步变为下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.maxBy&#123;p: People -&gt; p.age&#125;</span><br></pre></td></tr></table></figure></p><p>根据Kotlin的语法约定: <strong>如果Lambda表达式中参数的类型可以被推导出来,那么类型声明可以被省略。</strong><br>这个例子中编译器知道maxBy要处理的每一个元素都是People类型，所以这里不需要显式指定类型。<br>所以代码被进一步简化为下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.maxBy&#123;p -&gt; p.age&#125;</span><br></pre></td></tr></table></figure></p><p>当然我们前面也说了，Lambda就是一段代码，我们可以使用变量存储它，便于多次使用。当我们使用变量存储Lambda表达式时，由于缺少上下文环境，所以无法进行参数类型推断，所以必须显式指定参数类型。</p><p>根据Kotlin的语法约定: <strong>如果Lambda表达式中只有一个参数，并且这个参数的类型可以被推断出来，那么可以使用默认参数名称it来代替命名参数。</strong><br>所以最终代码变成了这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.maxBy&#123;it.age&#125;</span><br></pre></td></tr></table></figure></p><p>it虽然可缩短代码，但是却不可以滥用，在Lambda表达式嵌套的情况下，it没法清楚表示到底引用的是哪个值，会造成代码的混乱，所以在这种情况下建议显式指定参数名称。</p><p>最后再补充一个小点，Lambda表达式并没有限定是单个表达式，他截图包含更多的语句，当包含更多的语句时，最后一个表达式就是Lambda表达式的结果，就像下面这样:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">"start to calc..."</span>)</span><br><span class="line">        x + y</span><br><span class="line">    &#125;</span><br><span class="line">    println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>通过上面的介绍，是不是已经被Kotlin中的Lambda表达式吸引了呢，后续还有几篇文章将介绍Kotlin中Lambda表达式的更多内容。</p>]]></content>
    
    <summary type="html">
    
      “今天学习一下Kotlin中Lambda表达式第一部分。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之对象表达式</title>
    <link href="http://www.codekong.cn/2018/07/03/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.codekong.cn/2018/07/03/Kotlin系列之对象表达式/</id>
    <published>2018-07-03T15:11:16.000Z</published>
    <updated>2018-07-05T16:15:59.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天学习一下Kotlin中的对象表达式。</p></blockquote><p>对象表达式，是一种代替Java中的匿名内部类的方法。下面看看具体的用法，以及它与Java匿名内部类之间的区别。</p><h3 id="代替Java匿名内部类"><a href="#代替Java匿名内部类" class="headerlink" title="代替Java匿名内部类"></a>代替Java匿名内部类</h3><p>我们都知道Java的匿名内部类，这里给一个最简单的匿名内部类的Java代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] fileList  = <span class="keyword">new</span> File(<span class="string">"./"</span>).list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那上面的匿名内部类在Kotlin中应该怎么写呢，就是使用object关键字来进行编写，基本结构与Java匿名内部类还是非常相似的，代码示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fileList = File(<span class="string">"./"</span>).list(</span><br><span class="line">        <span class="keyword">object</span>: FilenameFilter &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重写其中的方法</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(dir: <span class="type">File</span>?, name: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>你会发现上面的用法跟匿名内部类非常像，当然其实上面的代码还是可以被优化的，只是这里特意写成这样来说明问题。</p><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p>在Java中匿名内部类智能只能继承一个类或者实现一个接口，而Kotlin的匿名对象可以实现多个接口或者不实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类实现了FilenameFilter接口</span></span><br><span class="line">String[] fileList  = <span class="keyword">new</span> File(<span class="string">"./"</span>).list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出上面的Java代码匿名内部类实现了FilenameFilter这个接口，并且只能实现一个。但是Kotlin却没有这个限制。代码示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aTest</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bTest</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象表达式实现多个接口</span></span><br><span class="line"><span class="keyword">val</span> myObj: Any = <span class="keyword">object</span> : A, B&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">aTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时上面的示例也可以看出，当我们的一个对象表达式的实例需要反复使用时，我们可以给该实例分配一个名字。</p><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们知道在Java中，被匿名内部类访问的变量必须被<strong>final</strong>修饰符修饰。代码示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Example</span><span class="params">(Window window)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    window.addMouseListener(<span class="keyword">new</span> MouseAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.mouseClicked(e);</span><br><span class="line">            <span class="comment">//错误，i必须声明为final的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在Kotlin中没有这种限制，对象表达式可以直接访问创建它的函数内部的变量，并且修改其值。同样是上面的例子我们看看Kotlin中的代码例子:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Example</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.mouseClicked(e)</span><br><span class="line">            <span class="comment">//i的值可以被正常修改</span></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看出上面Kotlin中i的值可以被正常修改不会报错。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>今天的对象表达式的知识点其实是object关键字的用法之一，它的出现可以很好地帮我们解决一些Kotlin编程中的特殊场景的问题。</p>]]></content>
    
    <summary type="html">
    
      “今天学习一下Kotlin中的对象表达式。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之伴生对象</title>
    <link href="http://www.codekong.cn/2018/07/02/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.codekong.cn/2018/07/02/Kotlin系列之伴生对象/</id>
    <published>2018-07-02T12:15:40.000Z</published>
    <updated>2018-07-03T15:15:24.737Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一节中说到了对象声明，这次我们聊聊对象声明的一种特殊情况，对象声明在一个类内部，也就是标题所说的伴生对象。</p></blockquote><p>伴生对象最简单直白的理解就是与一个类相伴而生的对象，由于它处于类内部，所以必然和包含它的类存在某种联系。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>伴生对象使用关键字<strong>companion</strong>来声明，看起来就像是在object关键字前面加的一个修饰符。它的一般格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 外部类名&#123;</span><br><span class="line">  companion object 伴生对象名&#123;</span><br><span class="line">      //属性</span><br><span class="line">      //方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的代码示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion Object..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现上面的代码中没有伴生对象名，因为它是可以省略的。下面就依次看看伴生对象都用在那些地方。</p><h4 id="弥补static关键字缺憾"><a href="#弥补static关键字缺憾" class="headerlink" title="弥补static关键字缺憾"></a>弥补static关键字缺憾</h4><p>在Java中有static关键字表示静态成属性和方法，但在Kotlin中没有static关键字，所以伴生对象和顶层函数一起来弥补了这一缺憾，还是看上面给出的第一个例子，那我们怎么去调用伴生对象中的方法呢。</p><p>上面的代码连伴生对象的名字都省略了，所以我们只能通过外部类来调用。格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.伴生对象内部方法</span><br></pre></td></tr></table></figure><p>如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    A.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然对于指定了伴生对象名的情况，调用格式如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.伴生对象名.伴生对象内部方法</span><br></pre></td></tr></table></figure><p>代码示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> KB&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion Object..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    B.testB()</span><br><span class="line">    B.KB.testB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你会发现，你在调用时仍然可以省略掉伴生对象名，就像Java中通过类名直接调用静态方法一样。<br>当然，对于在声明时省略了伴生对象名的情况，Kotlin也提供了一个叫<strong>Companion</strong>的默认名称，所以我们也可以像下面的方式进行调用:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion Object..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    A.test()</span><br><span class="line">    <span class="comment">//默认名称</span></span><br><span class="line">    A.Companion.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实伴生对象的出现也是为了弥补顶层函数的不足，顶层函数不能访问一个类中的private成员，而伴生对象是可以访问的，如下面代码所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//伴生对象中可以调用外部的私有成员</span></span><br><span class="line">            println(C().age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶层函数不能调用外部类的私有成员</span></span><br><span class="line">    println(C().age) <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>伴生对象在声明的时候可以像其他类那样实现接口，并实现接口中的方法，如下面的代码所示:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//伴生对象实现接口</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Log&#123;</span><br><span class="line">        <span class="comment">//实现接口的方法</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printLog</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"msg ------- <span class="variable">$msg</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法的参数是接口实例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLog</span><span class="params">(log: <span class="type">Log</span>)</span></span>&#123;</span><br><span class="line">    log.printLog(<span class="string">"msg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//传入实现接口的伴生对象的类</span></span><br><span class="line">    callLog(People)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码可以这样理解，伴生对象实现了接口，伴生对象又与外部类存在关联，所以相当于外部类也实现了接口，所以我们可直接传入外部类的名称，这里的这个名称就指代了那个伴生对象。</p><h4 id="伴生对象扩展"><a href="#伴生对象扩展" class="headerlink" title="伴生对象扩展"></a>伴生对象扩展</h4><p>在前面的内容中我们也说过方法扩展，那这里我们的伴生对象也可以进行扩展，我们可以在其上扩展我们自己的方法。这里所谓的扩展就是在声明伴生对象的时候没有指定函数，而是在类的外部来给伴生对象增加方法，来看看下面的代码示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">//伴生对象内部没有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//伴生对象扩展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.Companion.<span class="title">toJson</span><span class="params">(person: <span class="type">Person</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="keyword">val</span> str = Person.toJson(Person(<span class="string">"小白"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的扩展方法和函数的扩展差别不大，主要是要访问到扩展对象再在其上扩展方法。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>这一节的伴生对象，总觉得还是有点绕，而且使用场景比较多，容易出错，后续待理解更加深入了会再写文章介绍。</p>]]></content>
    
    <summary type="html">
    
      “上一节中说到了对象声明，这次我们聊聊对象声明的一种特殊情况，对象声明在一个类内部，也就是标题所说的伴生对象。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之对象声明</title>
    <link href="http://www.codekong.cn/2018/07/02/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E/"/>
    <id>http://www.codekong.cn/2018/07/02/Kotlin系列之对象声明/</id>
    <published>2018-07-01T16:07:45.000Z</published>
    <updated>2018-07-02T11:05:50.239Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>隔了比较久的一段时间了，继续来学习一点Kotlin，今天说说Kotlin中的对象声明。</p></blockquote><p>我们都知道在Java中，必须先有类，然后才能new出对象，也就是声明类和创建对象是两个分开的步骤，并有先后次序。在Kotlin中，我们可以使用<strong>object</strong>关键字在声明定义一个类的同时创建出一个对象，也就是我们标题所说的对象声明，下面就来一起看看对象声明的相关知识点。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>对象声明的基本格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 类名 &#123;</span><br><span class="line">    属性声明</span><br><span class="line">    方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象声明的使用格式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.属性</span><br><span class="line">类名.方法</span><br></pre></td></tr></table></figure></p><p>这里我们创建一个年级类的对象声明，代码如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.codekong.objectdeclare</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象声明</span></span><br><span class="line"><span class="keyword">object</span> Grade&#123;</span><br><span class="line">    <span class="keyword">val</span> allStudents = arrayListOf&lt;Student&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有学生年龄和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countAge</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (student <span class="keyword">in</span> allStudents)&#123;</span><br><span class="line">            sum += student.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用上面的对象声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    Grade.allStudents.add(Student(<span class="string">"小白"</span>, <span class="number">12</span>))</span><br><span class="line">    Grade.allStudents.add(Student(<span class="string">"小厅"</span>, <span class="number">13</span>))</span><br><span class="line">    Grade.allStudents.add(Student(<span class="string">"小红"</span>, <span class="number">14</span>))</span><br><span class="line">    Grade.allStudents.add(Student(<span class="string">"小明"</span>, <span class="number">15</span>))</span><br><span class="line"></span><br><span class="line">    print(Grade.countAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里大家可能觉得这个也没什么嘛，感觉跟Java中一个类中声明了static方法和static属性，然后通过类名直接调用一样嘛，当然这里可以这么类比Java进行理解，但是要记住在Kotlin中没有static这个关键字。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>看了上面的小例子，感觉还是很简单的，那这种对象声明用在什么地方呢？学了这个知识点终归是要用的啊。</p><p>1 . 用于创建单例对象<br>作为23种设计模式之一的单例模式，相信很多学习Java的小伙伴都是知道的，在Kotlin中，直接利用对象声明这个高级特性将类的声明和实例的创建结合在一起，就完美达到了单例模式的要求，如下代码所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="keyword">val</span> info =  <span class="string">"string"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">out</span><span class="params">(suffix: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$info</span>---<span class="variable">$suffix</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    Singleton.<span class="keyword">out</span>(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不能以其他方式创建Singleton的对象，所以它是满足单例模式的。</p><p>2 . 实现接口但是不包含状态<br>对象声明也可以像普通类那样实现接口，但是由于对象声明创建的实例只有一个，但可能被多次使用，所以一般不包含数据和状态，在这样的情况下，也可以使用对象声明，下面通过一个比较器的例子来说明，我们实现一个忽略大小写进行文件路径比较的例子，代码如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CaseInsensitiveFileComparator: Comparator&lt;File&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(file1: <span class="type">File</span>, file2: <span class="type">File</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> file1.path.compareTo(file2.path, ignoreCase = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fileList = listOf&lt;File&gt;(File(<span class="string">"/abc"</span>), File(<span class="string">"/aBc"</span>), File(<span class="string">"/aaa"</span>))</span><br><span class="line">    println(fileList.sortedWith(CaseInsensitiveFileComparator))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的路径比较是没有状态的，同时将我们自定义的声明对象传递给比较函数进行比较。</p><h4 id="与Java互操作"><a href="#与Java互操作" class="headerlink" title="与Java互操作"></a>与Java互操作</h4><p>一直在说Java和Kotlin有良好的互操作性，那么Kotlin中的对象声明在Java中该如何使用呢？<br>Kotlin中的对象声明被编译为Java中通过静态字段来持有的单一实例，这个实例的名字固定为<strong>INSTANCE</strong>，就好像我们在Java中调用Java定义的单例模式的实例一样。代码示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象声明</span></span><br><span class="line">object Grade&#123;</span><br><span class="line">    var allStudents = arrayListOf&lt;Student&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有学生年龄和的方法</span></span><br><span class="line">    <span class="function">fun <span class="title">countAge</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">        var sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (student in allStudents)&#123;</span><br><span class="line">            sum += student.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Java中的调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JObjectDeclare</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="string">"小雨"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        Grade.INSTANCE.setAllStudents(students);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>接着，我们说一下对象声明的使用注意事项:</p><p>1 . 对象声明可以包含属性、方法、初始化语句块</p><p>2 . 对象声明不可以使用构造方法(包括主构造方法和从构造方法)</p><p>3 . 对象声明可以被声明在一个类的内部</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>此处只是介绍了object关键字在对象声明中的用途，后续还会介绍更多object关键字的用处，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      “隔了比较久的一段时间了，继续来学习一点Kotlin，今天说说Kotlin中的对象声明。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之数据类和类委托</title>
    <link href="http://www.codekong.cn/2018/03/06/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%A7%94%E6%89%98/"/>
    <id>http://www.codekong.cn/2018/03/06/Kotlin系列之数据类和类委托/</id>
    <published>2018-03-06T14:22:12.000Z</published>
    <updated>2018-07-10T17:13:22.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天聊聊Kotlin中的数据类和委托类。</p></blockquote><p>在Java中是没有数据类和类委托的概念的。但是简单一点说数据类就是我们常说的Java中的Bean，它只是单纯为了表示数据而存在，就是一个方便的数据容器，而类委托表面看来就是主要实现将一个类委托给另一个类，具体内容我们往下看。</p><h4 id="Kotlin中的数据类"><a href="#Kotlin中的数据类" class="headerlink" title="Kotlin中的数据类"></a>Kotlin中的数据类</h4><p>上一节的代码中我们讨论了Kotlin中的通用对象方法，我们演示用的类就可以看作是一个数据类。代码如下</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">private</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"User&#123;name='<span class="variable">$name</span>', age=<span class="variable">$age</span>&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> User)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; age == other.age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = name.hashCode() ?: <span class="number">0</span></span><br><span class="line">        result = <span class="number">31</span> * result + age</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不知道大家有没有觉得重写这些方法也是有套路的，其实在IDEA等IDE中都有一键生成这种模板代码的功能，所以我们根本不需要写。其实不止如此，在Kotlin中还有更简单的方法。<br>具体做法就是在你的数据类前面加一个<code>data</code>关键字，Kotlin的编译器就会在背后自动帮你生成这些代码。就像下面这样。<br><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">private</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure></p><p>是不是超级简洁，对于编译器自动生成的方法。<br><code>equals()</code>用来比较实例<br><code>hashCode()</code>用来生成作为类似于HashMap这种基于哈希的容器的键<br><code>toString()</code>用来生成按声明顺序排列的所有属性字段的字符串表达形式<br>这里需要注意的一点是，<code>equals()</code>方法比较的字段是在<code>主构造方法</code>中声明的属性，<code>hashCode()</code>方法也是根据主构造方法中声明的属性来计算哈希值。没有在主构造方法中声明的属性不会加入到相等性检查和哈希值计算中去。</p><p>除了上面的三个方法，Kotlin编译器还为我们多生成了一个<code>copy()</code>方法。那么为什么会有这个方法呢？它是用来做什么的呢？<br>先说一下，我们在声明一个数据类时，为了实现对象的不可变性，一般要求我们将主构造方法主的属性都声明为val的，这样就可以保证数据类的实例在生成以后是不可变的和安全的，这在HashMap这种要求key不可变的容器中是非常重要的。同时在多线程情况下，对象会一直保持初始状态，也是安全的。</p><p>那么<code>copy()</code>方法是用来做什么的呢？该方法用来创建一个实例的副本，并且可以在创建时修改该副本实例的某些属性，就像下面这样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(atgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> user1 =  User(<span class="string">"遇见"</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user2 = user1.copy(name = <span class="string">"雨"</span>, age = <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">    println(user1)</span><br><span class="line">    println(user2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User(<span class="attribute">name</span>=遇见, <span class="attribute">age</span>=12)</span><br><span class="line">User(<span class="attribute">name</span>=雨, <span class="attribute">age</span>=21)</span><br></pre></td></tr></table></figure></p><h4 id="Kotlin中的类委托"><a href="#Kotlin中的类委托" class="headerlink" title="Kotlin中的类委托"></a>Kotlin中的类委托</h4><p>类委托，表面意思就是将一个类委托给另一个类，那它的应用场景是什么呢？我们下面举一个例子。<br>我们扩展一个集合类，统计我们一共向集合中添加了多少次元素，也就是我们做了多少次添加操作，这里我们先使用Java来实现一下。</p><p><strong>Java代码</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountableSet</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;T&gt; mList = <span class="keyword">new</span> HashSet&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">contains</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">toArray</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T1&gt; T1[] toArray(<span class="meta">@NotNull</span> T1[] a) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">toArray</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">add</span><span class="params">(t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">remove</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(@NotNull Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">containsAll</span><span class="params">(c)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(@NotNull Collection&lt;? <span class="keyword">extends</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        count += c.size();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">addAll</span><span class="params">(c)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(@NotNull Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">removeAll</span><span class="params">(c)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(@NotNull Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mList.<span class="title">retainAll</span><span class="params">(c)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们的做法是实现了一个集合类，在内部维护一个HashSet，在add()和addAll()方法中做添加次数统计，其他函数的实现我们都委托给HashSet的实例来完成即可。<br>可以看出上面的大部分代码都是很冗余的，我们为了添加一个小功能，就必须得添加一些多余的委托代码，这是非常不划算的。那么针对这种情况，Kotlin做了类委托，帮我们来自动完成。我们看看Kotlin中该怎么实现上面的功能呢。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountableSet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        count += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码先是在主构造方法中声明了一个<code>innerSet</code>实例，然后使用<code>by</code>关键字表示将所有函数操做都委托给该实例，同时，对于需要变化的函数，我们进行重写实现我们的具体逻辑即可，是不是代码量大大减少了，逻辑也清晰了很多。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>通过上面的例子，我们又一次感受到了Kotlin的简洁，它可以在保证功能的基础上大大减少代码量，使代码更简洁，逻辑更加清楚。</p>]]></content>
    
    <summary type="html">
    
      “今天聊聊Kotlin中的数据类和委托类。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之通用对象方法</title>
    <link href="http://www.codekong.cn/2018/03/04/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%9A%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://www.codekong.cn/2018/03/04/Kotlin系列之通用对象方法/</id>
    <published>2018-03-04T14:33:50.000Z</published>
    <updated>2018-07-02T11:05:50.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天我们来说说Kotlin中的通用对象方法。</p></blockquote><p>什么是通用对象方法呢？其实就是所有对象都拥有的方法，再进一步说，就是<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>。今天就来看看Kotlin中的这几个方法。</p><p>老规矩，先来稍微提一下在Java中这三个方法的一些知识点，再对比着来看。</p><h4 id="Java中的通用对象方法"><a href="#Java中的通用对象方法" class="headerlink" title="Java中的通用对象方法"></a>Java中的通用对象方法</h4><p>在Java中，这几个方法都是Object的方法。<br><code>toString()</code>是用来表示一个对象的字符串表示，它的出现大部分时候是为了将对象的属性以字符串形式表示打印出来。如果我们没有重写一个对象的<code>toString()</code>方法，那么它默认是<code>类名@53ffe12a</code>这样的形式。我们可以通过重写对象的该方法来使打印结果更直观更好理解。</p><p><code>equals()</code>方法是为了判断两个对象是否相等。默认情况下，它的作用和<code>==</code>的作用是一样的，都是比较两个对象的引用(地址)，我们可以通过重写该方法用于比较两个对象的属性是否相等。</p><p><code>hashCode()</code>方法最终是计算出一个对象的哈希值。</p><p>这里需要注意的是，在Java中有这样的契约：如果两个对象使用<code>equals()</code>方法比较相等，那么它们的<code>hashCode()</code>值也必须相等，但如果两个对象的<code>hashCode()</code>值相等，这两个对象不一点相等。</p><p>下面通过代码来简单看一下：</p><p><strong>Java代码</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params">String name, <span class="keyword">int</span>  age</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span>(<span class="params">Object o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != user.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.<span class="keyword">equals</span>(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="string">"雨"</span>, <span class="number">21</span>);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">"晴"</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(user1);</span><br><span class="line">        System.<span class="keyword">out</span>.println(user1.<span class="keyword">equals</span>(user2));</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(user1.hashCode());</span><br><span class="line">        System.<span class="keyword">out</span>.println(user2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User&#123;<span class="attribute">name</span>=<span class="string">'晴'</span>, <span class="attribute">age</span>=21&#125;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">813089</span><br><span class="line">1197613</span><br></pre></td></tr></table></figure><p>上面的代码重写了这几个方法，只是作为简单复习一下，那我们下面看看上面的代码用Kotlin该怎么写呢？</p><h4 id="Kotlin中的通用对象方法"><a href="#Kotlin中的通用对象方法" class="headerlink" title="Kotlin中的通用对象方法"></a>Kotlin中的通用对象方法</h4><p>在Kotlin中也是一样，我们也需要重写<code>toString()</code>方法。如下面这样。</p><p><strong>Kotlin代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"User&#123;name='<span class="variable">$name</span>', age=<span class="variable">$age</span>&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(atgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> user1 = User(<span class="string">"遇"</span>, <span class="number">21</span>);</span><br><span class="line">    println(user1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码重写了<code>toString()</code>方法，打印的结果和java是一样的。注意的是<code>override</code>关键字是强制的。同时上面还用到了<code>$变量名</code>这样的形式在字符串中直接引用变量，Kotlin会自动帮我们替换为对应的变量值，这在Kotlin中被成为模板字符串。</p><p>下面我们再来看看<code>equals()</code>方法和<code>hashCode()</code>方法的重写。与Java中一样的契约，<code>equals()</code>方法和<code>hashCode()</code>方法必须保持同步重写。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">private</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"User&#123;name='<span class="variable">$name</span>', age=<span class="variable">$age</span>&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> User)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; age == other.age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = name.hashCode() ?: <span class="number">0</span></span><br><span class="line">        result = <span class="number">31</span> * result + age</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码重写了<code>equals()</code>和<code>hashCode()</code>方法。</p><p>有人可能会有疑问，这里补充一下，<code>Any</code>相当于Java中的Object，但是下面在取name属性时并没有强制类型转化other的类型到User，这就是Kotlin中的重大特性之一<code>智能转换</code>。</p><p>有一点要注意，在Kotlin中<code>==</code>用来比较两个基本类型的值和两个对象，相当于Java中的<code>equals()</code>，它会在背后调用<code>equals()</code>方法，如果想比较两个对象的属性可以使用<code>===</code>。<br>这里再补充一下为什么需要保持<code>equals()</code>和<code>hashCode()</code>的一致性。我们都知道Set这种数据结构是保证其中的元素都是唯一的，只有一个，在HashSet这种集合中，做了优化，会先比较两个对象的哈希值，如果哈希值相等再比较两个对象的值，如果哈希值不想等则认为是两个相同的元素。如果我们不能保证对象的<code>equals()</code>和<code>hashCode()</code>的一致性，那么在使用这种集合时就会出错。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>通过上面的对比主要还是要注意<code>==</code>在Java和Kotlin中是不一样的，同时还发现同样的功能，Kotlink可以用更简洁的代码去实现，下面一节我们将会学到更简洁的代码。</p>]]></content>
    
    <summary type="html">
    
      “今天我们来说说Kotlin中的通用对象方法。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之接口中的属性</title>
    <link href="http://www.codekong.cn/2018/03/03/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.codekong.cn/2018/03/03/Kotlin系列之接口中的属性/</id>
    <published>2018-03-03T15:53:30.000Z</published>
    <updated>2018-07-02T11:05:50.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天我们看看如何让在Kotlin的接口中声明属性。</p></blockquote><p>在前面的文章中我们已经介绍过Kotlin中的接口，这里我们先复习一下，然后再重点说说Kotlin中的接口如何声明属性。</p><h4 id="Kotlin中的接口"><a href="#Kotlin中的接口" class="headerlink" title="Kotlin中的接口"></a>Kotlin中的接口</h4><p>下面是一段Kotlin中接口声明的代码，帮助大家复习一下。</p><p><strong>Kotlin代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">touch</span><span class="params">()</span></span> = println(<span class="string">"你触摸了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"点击了。。。"</span>)</span><br><span class="line">        touch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin中的接口声明属性"><a href="#Kotlin中的接口声明属性" class="headerlink" title="Kotlin中的接口声明属性"></a>Kotlin中的接口声明属性</h4><p>我们前面的文章在介绍接口时只是写了在接口中定义方法，所以我们下面说说如何在接口中声明属性。<br>我们知道在Java中，接口中的成员变量都是常量，也就是默认的修饰符是<code>public static final</code>类型的，那么在Kotlin中的规则又是什么样呢？</p><p>在Kotlin中，我们在接口中可以包含<code>抽象属性声明</code>，什么意思呢？也就是接口只需要定义属性，至于怎么给该属性赋值，怎么取该属性的值接口都不管，交给该接口具体的实现类来处理。如下面一样。</p><p><strong>Kotlin代码</strong></p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    val nickname: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的接口我们怎么实现呢？我们所谓的实现，其实就是给<code>nickname</code>这个属性赋值或者是获取这个属性的值。我们先看看第一种实现类。</p><p><strong>Kotlin代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivatePeople</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String) : People</span><br></pre></td></tr></table></figure><p>上面的代码有以下几点要解释一下:</p><p>1 . 使用<code>:</code>来表示实现一个接口<br>2 . 由于要给接口中的<code>nickname</code>属性赋值，所以这里使用了<code>主构造方法</code>并且使用<code>val</code>关键字为该实现类声明了一个属性<code>nickname</code>，换言之就是将初始化该实现类对象的属性赋值给了<code>nickname</code>属性，再者<code>val</code>声明的属性默认提供了获取值的方法。<br>3 . 使用<code>override</code>关键字表示重写了接口的<code>nickname</code>属性，这个是强制要求</p><p>除了上面使用主构造方法来实现接口的属性这种方法，还有一种在类内部重写的方式，代码如下：</p><p><strong>Kotlin代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPeople</span></span>(<span class="keyword">val</span> email: String): People&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickname: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">"@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> subPeople = SubPeople(<span class="string">"mo@qq.com"</span>)</span><br><span class="line">    println(subPeople.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式是我们实现了接口的<code>nickname</code>属性并且自定义了getter方法，使可以获取到nickname的值。同样需要注意，这里<code>override</code>关键字是强制要求。</p><h4 id="包含getter和setter的属性"><a href="#包含getter和setter的属性" class="headerlink" title="包含getter和setter的属性"></a>包含getter和setter的属性</h4><p>其实在接口中，除了抽象声明属性，我们还可以写包含getter和setter的属性，但是需要注意的是getter和setter不能引用需要保存状态的字段，因为接口是不允许保存状态的，就如下面这样。</p><p><strong>Kotlin代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> email: String</span><br><span class="line">    <span class="keyword">val</span> nickname: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">"@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivatePeople</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String, <span class="keyword">override</span> <span class="keyword">val</span> email: String) : People</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPeople</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> email: String): People&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickname: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">"@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> subPeople = SubPeople(<span class="string">"mo@qq.com"</span>)</span><br><span class="line">    println(subPeople.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们为<code>nickname</code>自定义了getter，这是允许的。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>这一次我们进一步学习了接口，探讨了在Kotlin中在接口中定义属性的规则，可以看出Kotlin在这一块比Java更加灵活。</p>]]></content>
    
    <summary type="html">
    
      “今天我们看看如何让在Kotlin的接口中声明属性。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之从构造方法</title>
    <link href="http://www.codekong.cn/2018/03/03/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://www.codekong.cn/2018/03/03/Kotlin系列之从构造方法/</id>
    <published>2018-03-03T14:17:38.000Z</published>
    <updated>2018-07-02T11:05:50.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一节说到了Kotlin中的主构造方法和初始化语句块，今天来看看Kotlin中的从构造方法。</p></blockquote><h4 id="在Java中的问题"><a href="#在Java中的问题" class="headerlink" title="在Java中的问题"></a>在Java中的问题</h4><p>在Java中，我们有时候为了用不同的参数来创建一个对象，就会声明多个构造方法，也就是构造方法的重载。然后我们可能会让某些构造方法的某些参数为默认值。在Java中是没有主构造方法和从构造方法的概念的，都叫构造方法，就像下面这样。</p><p><strong>Java代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = nickname;</span><br><span class="line">        <span class="keyword">this</span>.mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String nickname, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = nickname;</span><br><span class="line">        <span class="keyword">this</span>.mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码的mAge属性在我们不传入时使用默认值10。这样的场景在我们编程中经常遇到，那么在Kotlin中我们又该怎么写呢。</p><h4 id="Kotlin中的从构造方法"><a href="#Kotlin中的从构造方法" class="headerlink" title="Kotlin中的从构造方法"></a>Kotlin中的从构造方法</h4><p>我们先复习一下Kotlin中的主构造方法和从构造方法的区别。<br><code>主构造方法</code>是主要而简洁的初始化类的方法，声明在类的外部。<br><code>从构造方法</code>是声明在类内部的初始化类的方法。<br>就如下面的这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主构造方法</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> isMan: <span class="built_in">Boolean</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(nickname: String) : <span class="keyword">this</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(nickname: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> user =  User(<span class="string">"小米"</span>, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的主构造方法使用了<code>val</code>关键字，这样就是在声明主构造方法的时候为该类声明了一个属性<code>isMan</code>。<br>上面定义在类内部的就是从构造方法，为了实现用不同的参数初始化对象，这里定义了两个从构造方法。有人可能对上面的<code>this</code>的使用存在疑问。上面的<code>this</code>与Java中一样，用于在同一个类中调用其他的主构造方法或者从构造方法。</p><p>还有一个疑问，<code>: this(true)</code>这个可以不写吗？答案是不可以。因为我们定义了主构造，所以Kotlin中限定我们的从构造方法必须要直接或者间接委托给主构造方法，也就是我们也可以委托给另一个从构造方法，但委托链的最终要委托给主构造方法。</p><p>就像下面这样</p><p><strong>Kotlin代码</strong><br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主构造方法</span></span><br><span class="line">open <span class="keyword">class</span> User(val isMan: Boolean)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //从构造方法</span></span><br><span class="line"><span class="comment">    constructor(nickname: String) : this(true) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">constructor</span><span class="params">(nickname: <span class="keyword">String</span>, age: Int)</span> :</span> this(nickname) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中<code>constructor(nickname: String, age: Int)</code>委托了 <code>constructor(nickname: String)</code>，然后<code>constructor(nickname: String)</code>又委托给了主构造方法，在这条委托链的末端就是主构造方法。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>今天的内容很少，就只是单纯说说Kotlin中的从构造方法，这在Java中是没有这个概念的，同时他还介绍了从构造方法的委托规则。</p>]]></content>
    
    <summary type="html">
    
      “上一节说到了Kotlin中的主构造方法和初始化语句块，今天来看看Kotlin中的从构造方法。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之主构造方法和初始化语句块</title>
    <link href="http://www.codekong.cn/2018/02/07/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E5%9D%97/"/>
    <id>http://www.codekong.cn/2018/02/07/Kotlin系列之主构造方法和初始化语句块/</id>
    <published>2018-02-07T05:18:48.000Z</published>
    <updated>2018-07-02T11:05:50.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面我们已经说过类和接口的知识点，今天来看看Kotlin中的主构造方法和初始化语句块。</p></blockquote><p>我们知道在Java中也存在<code>构造方法</code>的概念，也有<code>初始化块</code>的概念。所以今天还是拿Kotlin和Java进行对比学习。</p><h4 id="Java中的构造方法和初始化块"><a href="#Java中的构造方法和初始化块" class="headerlink" title="Java中的构造方法和初始化块"></a>Java中的构造方法和初始化块</h4><p>在Java中构造方法有以下几点的规则。<br>1 . 构造方法没有返回值，方法名必须与类名相同</p><p>2 . 如果没有显式声明构造方法，Java会给我们生成一个默认的不带任何参数的构造方法</p><p>在Java中的初始化块又分为<code>普通初始化块</code>和<code>静态初始化块</code>，他们的规则如下。<br>1 . <code>普通初始化块</code>在每次对象创建时被调用，<code>静态初始化块</code>只在类被加载时调用，且只会被调用一次</p><p>2 . <code>普通初始化块</code>用来在一个对象创建时初始化其中的一些参数</p><p>下面通过代码来简单解释以下上面的规则。</p><p><strong>Java代码</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package ja;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="comment">//静态初始化代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"类被加载了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通初始化代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法用来初始化参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> other</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">value</span> + <span class="keyword">this</span>.num + other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面都是java的基础知识，写出来主要是方便与Kotlin的进行对比。</p><h4 id="Kotlin中的主构造方法和初始化语句块"><a href="#Kotlin中的主构造方法和初始化语句块" class="headerlink" title="Kotlin中的主构造方法和初始化语句块"></a>Kotlin中的主构造方法和初始化语句块</h4><p>在Kotlin中也存在和Java中相似的概念，但也又一些差异。<br>这里有一个概念是<code>主构造方法</code>。在Kotlin中一个类同样可以声明多个构造方法，但Kotlin将他们分为<code>主构造方法</code>和<code>从构造方法</code>。<br><code>主构造方法</code>是一个主要且简洁的初始化类的方法，而且它声明在类的外部，而<code>从构造方法</code>是声明在类的内部。今天我们先说说<code>主构造方法</code>和与之相关的<code>初始化语句块</code>。</p><p>在Kotlin中构造方法的声明需要使用到<code>constructor</code>关键字，初始化语句块的声明需要使用到关键字<code>init</code>。在Kotlin中构造方法一般是用于传入一些创建类时需要的参数，配合初始化语句块来对类的属性进行初始化。下面用代码来实际说一下。</p><p><strong>Kotlin代码</strong><br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类的主构造方法需要传入name参数</span></span><br><span class="line"><span class="keyword">class</span> User <span class="function"><span class="keyword">constructor</span><span class="params">(<span class="keyword">name</span>: <span class="keyword">String</span>)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    //类的name属性</span></span></span><br><span class="line"><span class="function"><span class="comment">    val name: String</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    //初始化语句块用于配合构造方法给属性赋初始值</span></span></span><br><span class="line"><span class="function"><span class="comment">    init &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        this.name = name</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>上面的代码还是很好理解的，其实就相当于把我们的构造方法和类的声明放在了一起。注意上面的<code>this</code>和我们java中的用法是一样的，都是在于构造方法的参数名和类的属性名相同时来区分两者。</p><p>当然Kotlin是一门追求简洁的语言，我们可以把上面的代码进一步简化。像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> User (<span class="keyword">name</span>: String)&#123;</span><br><span class="line">    //类的<span class="keyword">name</span>属性</span><br><span class="line">    val <span class="keyword">name</span> = <span class="keyword">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接省略了<code>constructor</code>关键字和初始化语句块，直接赋值即可。</p><p>当你觉得这样已经够简洁的时候，还有更简洁的，想下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class<span class="built_in"> User </span>(val name: String)</span><br></pre></td></tr></table></figure></p><p>直接将<code>val</code>关键字加载构造方法属性前面，就完成了构造方法参数的声明和类属性的声明和赋值，甚至连<code>{}</code>也不需要了。</p><h4 id="Kotlin中的构造方法新特性"><a href="#Kotlin中的构造方法新特性" class="headerlink" title="Kotlin中的构造方法新特性"></a>Kotlin中的构造方法新特性</h4><p>除了上面简洁的语法，还有很多新特性。我们在前面的文章中说过，一个方法的参数可以又默认值，也可以在传入方法参数时带上参数名使代码可读性更好。由于构造方法也是方法，我们同样可以使用这些特性，就像下面代码描述的那样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法参数带默认值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> isMan: <span class="built_in">Boolean</span> = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>那我们如何使用上面的类呢？</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第二个参数使用了默认值</span></span><br><span class="line">    <span class="keyword">val</span> user1 =  User(name = <span class="string">"Mike"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user2 = User(name = <span class="string">"Tom"</span>, isMan = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是代码简洁清楚了很多呢。</p><h4 id="Kotlin构造方法与继承"><a href="#Kotlin构造方法与继承" class="headerlink" title="Kotlin构造方法与继承"></a>Kotlin构造方法与继承</h4><p>我们知道在Java中如果我们没有显式声明一个构造方法，就会为我们默认添加一个无参的构造方法，在Kotlin中也是一样的。<br>那么当我们涉及到继承时，我们该怎么写呢？在Kotlin中当你继承一个类不再只是写出类名就可以了，而是要给你继承类的构造方法同时传入参数j将，就像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> isMan: <span class="built_in">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleUser</span></span>(name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>): User(name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们创建<code>GoogleUser</code>这个子类，并且将它的构造方法的name参数传递给了父类的构造方法。同时我们还为子类增加了一个新的属性<code>age</code>。<br>当然，如果我们继承的父类没有指定构造方法，由于有默认构造方法的存在，我们在继承时必须要注意。像下面的代码一样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="type">Father</span></span>()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们在继承father类时必须有<code>()</code>，因为这里的意义是构造方法。</p><p>我们前面也说过接口是没有构造方法，不能被实例化的，所以就没有<code>()</code>，像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="type">Clickable&#123;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>可以看出Kotlin在模仿Java的一些方面的同时，可以保证我们用更简洁清楚和更少的代码来完成我们的工作。</p>]]></content>
    
    <summary type="html">
    
      “前面我们已经说过类和接口的知识点，今天来看看Kotlin中的主构造方法和初始化语句块。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之密封类</title>
    <link href="http://www.codekong.cn/2018/02/06/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%86%E5%B0%81%E7%B1%BB/"/>
    <id>http://www.codekong.cn/2018/02/06/Kotlin系列之密封类/</id>
    <published>2018-02-06T05:10:44.000Z</published>
    <updated>2018-07-02T11:05:50.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天说说Kotlin中的密封类。</p></blockquote><p>在Java中没有<code>密封类</code>这个概念，所以就没法和Java进行对比了，主要看看Kotlin中的密封类的出现目的和使用方法。</p><h4 id="为什么会出现密封类"><a href="#为什么会出现密封类" class="headerlink" title="为什么会出现密封类"></a>为什么会出现密封类</h4><p>我们先不说<code>密封类</code>是什么，先看看为什么需要密封类。下面先通过一段代码来看。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FatherClass</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonClass1</span>: <span class="type">FatherClass&#123;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonClass2</span>: <span class="type">FatherClass&#123;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(fatherClass: <span class="type">FatherClass</span>)</span></span>: String =</span><br><span class="line">    <span class="keyword">when</span>(fatherClass)&#123;</span><br><span class="line">        <span class="keyword">is</span> SonClass1 -&gt; <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">is</span> SonClass2 -&gt; <span class="string">"2"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown Class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> son1 = SonClass1();</span><br><span class="line">    <span class="keyword">val</span> result = check(son1)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中定义了一个接口，然后两个类实现这个接口。我们在<code>check</code>方法中通过传入接口对象，使用<code>when</code>来判断传入的对象是哪种类型。关于<code>when</code>的使用，可以查看以前的文章有专门介绍。这里使用<code>when</code>时，必须要添加一个<code>else分支</code>，否则会报错，无法编译通过。</p><p>但是上面的代码存在一个潜在的问题。假如我们这时候再添加一个子类，这时候<code>when</code>并没有发现我们的子类增加了，也不会报错，可能我们需要给<code>when</code>增加一个新的分支，但是由于没有报错，可能就会被我们忽略了。</p><p>基于上面的原因，Kotlin为了解决上面的潜在问题，便提出了<code>密封类</code>。</p><h4 id="密封类的使用"><a href="#密封类的使用" class="headerlink" title="密封类的使用"></a>密封类的使用</h4><p><code>密封类</code>需要使用<code>sealed</code>关键字修饰，并且被<code>sealed</code>关键字修饰的类，它的子类必须要以<code>嵌套类</code>的形式在父类中全部声明，关于<code>嵌套类</code>的想关内容可以查看上一节的文章。下面写一个<code>密封类</code>的例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SealedClass</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass1</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass2</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你看过前面的内容，你就会有疑问，Kotlin中的类不是默认<code>final</code>的吗？为什么可以被继承呢？<br>这是因为被<code>sealed</code>修饰的类默认是<code>open</code>的，所以可以被继承，而不需要显式使用<code>open</code>修饰符。</p><p>那我看看密封类的出现，会怎么解决我们上面提出的问题呢？看下面的代码</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SealedClass</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass1</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass2</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(sealedClass: <span class="type">SealedClass</span>)</span></span>: String =</span><br><span class="line">    <span class="keyword">when</span>(sealedClass)&#123;</span><br><span class="line">        <span class="keyword">is</span> SealedClass.SonClass1 -&gt; <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">is</span> SealedClass.SonClass2 -&gt; <span class="string">"2"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>你会发现<code>when</code>结构中少了<code>else分支</code>。对因为在密封类中已经列出了所有的密封类的所有子类，所以就不会有<code>else</code>的情况。<br>这样之后，你每次增加一个子类，<code>when</code>结构就会检查到你增加了子类，就必须要给<code>when</code>结构添加一个分支，否则就会编译报错，这样就把潜在的问题消灭在了编译阶段。<br>就像下面这样，增加一个子类必须增加相应的<code>when分支</code>。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SealedClass</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass1</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass2</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SonClass3</span>: <span class="type">SealedClass</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(sealedClass: <span class="type">SealedClass</span>)</span></span>: String =</span><br><span class="line">    <span class="keyword">when</span>(sealedClass)&#123;</span><br><span class="line">        <span class="keyword">is</span> SealedClass.SonClass1 -&gt; <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">is</span> SealedClass.SonClass2 -&gt; <span class="string">"2"</span></span><br><span class="line">        <span class="keyword">is</span> SealedClass.SonClass3 -&gt; <span class="string">"3"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>Kotlin中的密封类的出现，在于它定义了一种受限的类继承结构，可以保证我们写出更安全的代码。</p>]]></content>
    
    <summary type="html">
    
      “今天说说Kotlin中的密封类。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之内部类和嵌套类</title>
    <link href="http://www.codekong.cn/2018/02/05/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
    <id>http://www.codekong.cn/2018/02/05/Kotlin系列之内部类和嵌套类/</id>
    <published>2018-02-05T03:40:30.000Z</published>
    <updated>2018-07-02T11:05:50.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天我们再来看看Kotlin中的内部类和嵌套类。</p></blockquote><p>还是一样的套路，我们要和Java进行对比学习。</p><h4 id="Java中的内部类和静态内部类"><a href="#Java中的内部类和静态内部类" class="headerlink" title="Java中的内部类和静态内部类"></a>Java中的内部类和静态内部类</h4><p>在Java中<code>内部类</code>简言之就是在一个类的内部定义的另一个类。当然在如果这个内部类被<code>static</code>修饰符修饰，那就是一个<code>静态内部类</code>。</p><p>关于<code>内部类</code> 和<code>静态内部类</code>除了修饰符的区别之外，最主要的是<code>内部类</code>会默认持有一个外部类的引用，也正是这个原因内部类可以直接引用外部类的属性和方法，而不受制于外部类中属性和方法的修饰符。而<code>静态内部类</code>不持有外部类的应用，所以基本跟一个外部类没有什么区别。</p><p>下面用代码来说明一下上面的规则。<br><strong>Java代码</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package ja;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OutClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">InnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//直接可以调用外部类的方法</span></span><br><span class="line">            <span class="keyword">add</span>();</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//不持有外部类的引用，所以必须通过外部类的对象来访问</span></span><br><span class="line">            OutClass outClass = <span class="keyword">new</span> OutClass();</span><br><span class="line">            outClass.<span class="keyword">add</span>();</span><br><span class="line">            <span class="keyword">return</span> outClass.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package ja;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//必须现new出外部类的对象，才能new出内部类的对象</span></span><br><span class="line">        OutClass.InnerClass innerClass = <span class="keyword">new</span>  OutClass().new InnerClass();</span><br><span class="line">        <span class="keyword">int</span> res = innerClass.getSomething();</span><br><span class="line">        System.<span class="keyword">out</span>.println(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态内部类直接可以new出内部类的对象</span></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = staticInnerClass.getValue();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出最主要的差别就是内部类会隐式持有一个外部类的引用。</p><h4 id="Kotlin中的内部类和嵌套类"><a href="#Kotlin中的内部类和嵌套类" class="headerlink" title="Kotlin中的内部类和嵌套类"></a>Kotlin中的内部类和嵌套类</h4><p>在Kotlin中的内部类也是指在一个类的内部声明另一个类，但是和Java中的规则有些差异。</p><p>在Kotlin中的内部类和Java中的内部类相似，都会持有一个外部类的引用，但是在Kotlin中内部类的声明方式变化了，必须要使用<code>inner</code>修饰符。</p><p>在Kotlin中，没有静态内部类一说，Java中的<code>静态内部类</code>在Kotlin中称为<code>嵌套类</code>。而且默认就是嵌套类，也就是内部类不写任何修饰符就是<code>嵌套类</code>。</p><p>同样的，<code>内部类</code>会持有一个外部类的引用，<code>嵌套类</code>不持有外部类的引用。</p><p>下面通过代码来说明一下。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getSomething</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">            <span class="comment">//默认持有外部类的引用，直接访问外部类的方法属性</span></span><br><span class="line">            add()</span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@OutClass</span>.add()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span><span class="symbol">@OutClass</span>.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">            <span class="comment">//嵌套类不持有外部类的引用，必须通过外部类的对象访问</span></span><br><span class="line">            <span class="keyword">val</span> outClass = OutClass()</span><br><span class="line">            outClass.add()</span><br><span class="line">            <span class="keyword">return</span> outClass.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> outClass = OutClass()</span><br><span class="line">    <span class="keyword">val</span> innerClass = outClass.InnerClass()</span><br><span class="line">    <span class="keyword">val</span> res = innerClass.getSomething()</span><br><span class="line">    println(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> nestedClass = OutClass.NestedClass()</span><br><span class="line">    <span class="keyword">val</span> value =  nestedClass.getValue()</span><br><span class="line">    println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是使用Kotlin来实现了一下前面Java的代码，你会发现还是有很多相似之处的。<br>当然在Koltlin内部类中，可以使用<code>this@OutClass</code>去访问外部类的属性和方法。</p><p>下面我们通过表格来对比一下Java和Kotlin中的内部类。</p><table><thead><tr><th>类A在另一个类B中声明</th><th>在Java中</th><th>在Kotlin中</th></tr></thead><tbody><tr><td>嵌套类(不存储外部类的引用)</td><td>static class A</td><td>class A</td></tr><tr><td>内部类(存储外部类的引用)</td><td>class A</td><td>inner class A</td></tr></tbody></table><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>通过Java和Kotlin的对比，可以看出为了Kotlin与Java良好的互操作性，两种语言还是有很多相似之处的。</p>]]></content>
    
    <summary type="html">
    
      “今天我们再来看看Kotlin中的内部类和嵌套类。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之可见性修饰符</title>
    <link href="http://www.codekong.cn/2018/02/03/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://www.codekong.cn/2018/02/03/Kotlin系列之可见性修饰符/</id>
    <published>2018-02-02T16:06:22.000Z</published>
    <updated>2018-07-02T11:05:50.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天一起来看看Kotlin中的可见性修饰符。</p></blockquote><h4 id="Java的访问修饰符"><a href="#Java的访问修饰符" class="headerlink" title="Java的访问修饰符"></a>Java的访问修饰符</h4><p>首先也是简单先说一下Java中的可见性修饰符相关的概念，这里用一个表格来对比着看一下。</p><table><thead><tr><th>访问修饰符</th><th>类</th><th>包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>x</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>x</td><td>x</td></tr><tr><td>private</td><td>√</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><p>上面看出Java的默认访问权限是<code>包访问权限</code>，其他的访问控制修饰都是Java基础知识了，这里不再赘述。</p><h4 id="Kotlin的访问修饰符"><a href="#Kotlin的访问修饰符" class="headerlink" title="Kotlin的访问修饰符"></a>Kotlin的访问修饰符</h4><p>Kotlin的访问修饰符与Java中有些类似，但也存在一定的差异。在Kotlin中，没有包访问权限这这种可见性控制，Kotlin中只是将包作为一种组织代码的方式，类似于命名空间。</p><p>同时，Kotlin提供了一种新的修饰符<code>internal</code>，表示只在<code>模块</code>内可见。这里的模块指一组一起编译的Kotlin文件。可能是一个IDEA模块，也可能是一个项目。这种模块级别的访问控制可以真正做到将代码的具体实现封装在模块内部，实现了真正的封装，而Java的默认包控制权限，可能会有人将代码写在同一个包下，而破坏这种封装性。</p><p>在Kotlin中<code>protected</code>修饰符与Java中不同，由于没有包访问控制的概念，所以在<code>Kotlin</code>中，<code>protected</code>就只是控制父类与子类之间的访问权限控制。</p><p>Kotlin中的<code>public</code>、<code>protected</code>、<code>private</code>修饰符与Java中的用法是一样的。但是在Kotlin中默认的访问修饰符是<code>public</code>，也就是如果你不显式指定修饰符，默认就是<code>public</code>的。下面上代码看一下。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">privateFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是私有方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">protectedFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是protected方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">internalFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是internal方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">publicFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是public方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//都可以访问到</span></span><br><span class="line">        publicFun()</span><br><span class="line">        protectedFun()</span><br><span class="line">        internalFun()</span><br><span class="line">        privateFun()</span><br><span class="line">        println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在子类中private是访问不到的</span></span><br><span class="line">        publicFun()</span><br><span class="line">        protectedFun()</span><br><span class="line">        internalFun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> view = View()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能访问到public和internal方法</span></span><br><span class="line">        view.publicFun()</span><br><span class="line">        view.internalFun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面的文章中也说到了<code>顶层函数和属性</code>。与Java中有所差异的是，<code>private</code>修饰符不光可以用来修饰类与方法和属性，还可以修饰顶层函数和属性。一旦顶层函数和属性被<code>private</code>修饰，那么这些声明就只会在声明它的文件中可见。</p><p>当然我们前面也说过<code>扩展函数</code>，这里有一点要注意的是，扩展函数不可以访问到类中被<code>private</code>和<code>protected</code>修饰的成员。如下代码所示。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在子类中private是访问不到的</span></span><br><span class="line">        publicFun()</span><br><span class="line">        protectedFun()</span><br><span class="line">        internalFun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Layout.<span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"我是扩展函数"</span>)</span><br><span class="line">    publicFun()</span><br><span class="line">    internalFun()</span><br><span class="line">    <span class="comment">//扩展函数不能访问到protected和private的成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="可见性修饰符总结对比"><a href="#可见性修饰符总结对比" class="headerlink" title="可见性修饰符总结对比"></a>可见性修饰符总结对比</h4><p>下面通过表格来对比一下这几种可见性修饰符</p><table><thead><tr><th>修饰符</th><th>类成员</th><th>顶层声明</th></tr></thead><tbody><tr><td>public(默认)</td><td>所有地方可见</td><td>所有地方可见</td></tr><tr><td>internal</td><td>模块中可见</td><td>模块中可见</td></tr><tr><td>protected</td><td>子类中可见</td><td>/</td></tr><tr><td>private</td><td>类中可见</td><td>文件中可见</td></tr></tbody></table><h4 id="Kotlin的声明在Java中的处理"><a href="#Kotlin的声明在Java中的处理" class="headerlink" title="Kotlin的声明在Java中的处理"></a>Kotlin的声明在Java中的处理</h4><p>由于Kotlin是可以被Java调用的，那我们就需要知道Kotlin代码在被编译为字节码被Java调用时，这些访问控制是怎么被处理的。</p><p>1 . <code>private</code>、<code>protected</code>、<code>public</code>会被保留，使用方式与Java中相同</p><p>2 . <code>internal</code>在字节码中被处理为<code>public</code><br>所以为了保持Kotlin与Java良好的互操作性，当我们用Java访问Kotlin时，一些访问控制和封装性似乎被破坏了。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>可以看到Kotlin借鉴了Java访问控制符的做法，但同时也完善了自己的一些访问控制，以便于提供更好的封装性，来获得更加优雅安全的代码。</p>]]></content>
    
    <summary type="html">
    
      “今天一起来看看Kotlin中的可见性修饰符。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之继承相关修饰符</title>
    <link href="http://www.codekong.cn/2018/02/01/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://www.codekong.cn/2018/02/01/Kotlin系列之继承相关修饰符/</id>
    <published>2018-01-31T17:02:50.000Z</published>
    <updated>2018-07-02T11:05:50.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin同Java一样也有一些针对类、成员、和方法的修饰符，今天我们先看看和继承相关的几个修饰符。</p></blockquote><p>与继承相关的几个修饰符主要包括<code>final</code>、<code>open</code>、<code>abstract</code>、<code>override</code>，下面我们通过具体的例子来说说他们的具体使用。</p><h4 id="类和方法默认是final的"><a href="#类和方法默认是final的" class="headerlink" title="类和方法默认是final的"></a>类和方法默认是final的</h4><p>在Java中，类默认是可以被继承的，方法默认是可以被重写的。除非你将类或者方法使用<code>final</code>关键字进行修饰。但是在Kotlin中，类和方法默认是<code>final</code>的，也就是类默认不能被继承，方法默认不能被重写，比如下面的代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的这个类和其中的getWidth()方法就默认是使用final修饰的，也就是这个类是不可以被继承的其中的getWidth()方法也是不可被重写的。</p><h4 id="使用open开放类和方法"><a href="#使用open开放类和方法" class="headerlink" title="使用open开放类和方法"></a>使用open开放类和方法</h4><p>上面说了，一个类默认不能被继承，那怎么才能让其可以被继承呢？那就使用<code>open</code>关键字修饰它，就如下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开放类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextView</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如你上面看到的那样，与实现接口类似，都是使用<code>:</code>来表示继承，这里的<code>View()</code>是不是有点奇怪，在上一节的实现接口时是没有<code>()</code>的。这里先简单说一下这是表示父类构造方法，后面我们会详细说。<br>虽然类可以被继承了，但是由于<code>getWidth()</code>方法还是<code>final</code>的，所以不能被重写。同样使用<code>open</code>修饰方法。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="comment">//开放方法重写</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextView</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line">    <span class="comment">//重写方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会注意到，我们在重写时，必须在子类中对那个被我们重写的方法添加<code>override</code>修饰符，这是强制的，否则就会编译错误。<br>当我们重写了父的方法，在子类中这方法就默认是<code>open</code>的，也就是这个方法可以被重写了，就像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line">    <span class="comment">//被重写的方法默认是open的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickableTextView</span>: <span class="type">TextView</span></span>()&#123;</span><br><span class="line">    <span class="comment">//可以重写父类的方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getWidth()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候我们可能在重写了父类的某个方法后，不希望我们的子类可以继续重写我们的方法，其实也是很容易的，只要给方法显式添加<code>final</code>修饰符即可，就如下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span>: <span class="type">View</span></span>()&#123;</span><br><span class="line">    <span class="comment">//final修饰后override方法不再可以被重写</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="abstract声明抽象类和方法"><a href="#abstract声明抽象类和方法" class="headerlink" title="abstract声明抽象类和方法"></a>abstract声明抽象类和方法</h4><p>同Java中一样，<code>abstract</code>可以用来声明一个抽象类或者是一个抽象方法。抽象类是不可以被实例化的，抽象方法必须被重写。所以就保证了，只要是被<code>abstract</code>修饰的类和方法，默认就是<code>open</code>的，因为它们的存在本来就是要被用来继承和重写的。就如下面一样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类默认是open的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span>&#123;</span><br><span class="line">    <span class="comment">//抽象类中的普通方法默认是fianl的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法默认是open的</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">setSomething</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImgButton</span>: <span class="type">Button</span></span>()&#123;</span><br><span class="line">    <span class="comment">//抽象方法必须被重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面代码中一样，抽象类中的普通方法，默认是<code>final</code>，不能被重写，但是抽象方法默认是open的，而且抽象方法必须要在继承类中被重写，同时必须显式指定<code>override</code>修饰符。</p><h4 id="override声明重写的方法"><a href="#override声明重写的方法" class="headerlink" title="override声明重写的方法"></a>override声明重写的方法</h4><p>其实<code>override</code>在上面的代码中已经多次出现了，它是Kotlin规定必须对重写的方法显式指定的修饰符，否则会编译出错。其实<code>override</code>还有另一层用法，使用<code>override</code>修饰的方法默认都是<code>open</code>的，可以被后面的子类重写，要是不想被重写，那就必须手动声明<code>final</code>修饰符。由于代码和前面的示例代码一样，这里就不再重复了。</p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><p>这里通过一个表格，简单对比总结一下上面的几种修饰符。</p><table><thead><tr><th>修饰符</th><th>对成员方法的要求</th><th>备注</th></tr></thead><tbody><tr><td>final</td><td>不能被重写</td><td>类中成员默认</td></tr><tr><td>open</td><td>可以被重写</td><td>必须明确指定</td></tr><tr><td>abstract</td><td>必须被重写</td><td>用于抽象类中</td></tr><tr><td>override</td><td>重写父类或接口中的方法</td><td>override修饰的方法默认是open的</td></tr></tbody></table><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>在这一节，与Java相比，Kotlin貌似增加了许多新的规则和强硬的措施，看似是多余麻烦的，其实这是在改善Java以前存在的一些潜在问题，让Kotlin变成一门安全的语言。</p>]]></content>
    
    <summary type="html">
    
      “Kotlin同Java一样也有一些针对类、成员、和方法的修饰符，今天我们先看看和继承相关的几个修饰符。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之接口</title>
    <link href="http://www.codekong.cn/2018/01/29/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.codekong.cn/2018/01/29/Kotlin系列之接口/</id>
    <published>2018-01-29T15:11:14.000Z</published>
    <updated>2018-07-02T11:05:50.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天说说Kotlin中的接口。</p></blockquote><p>还是同样的，在说Kotlin中的接口之前先来说说Java中的接口。然后对比着来学习。</p><h4 id="Java中的接口"><a href="#Java中的接口" class="headerlink" title="Java中的接口"></a>Java中的接口</h4><p>先上一段代码吧，然后再总结一下Java中的接口的一些相关知识点。</p><p><strong>Java代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span> </span>&#123;</span><br><span class="line">    String mFlag = <span class="string">"flag"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">implements</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(mFlag + <span class="string">" 点击了 "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面几行代码包含了如下的知识点：<br>1 . 使用<code>interface</code>关键字声明一个接口<br>2 . 接口中的成员变量都是常量，也就是默认的修饰符是<code>public static final</code>类型的<br>3 . 接口中的成员方法都是抽象方法，默认的修饰符是<code>public abstract</code>，抽象方法没有方法体<br>4 . 接口是可以<code>多继承</code>的<br>5 . 一个类使用<code>implements</code>来实现接口， 一个类可以实现多个接口，实现接口的类要么声明为抽象类，要么就要全部实现接口中的方法<br>6 . 接口没有构造方法，所以不能被实例化<br>上面这几点都是Java的基础知识点，这里就不再赘述，主要是写出来便于与后面Kotlin接口的规则做对比。</p><h4 id="Kotlin中的接口"><a href="#Kotlin中的接口" class="headerlink" title="Kotlin中的接口"></a>Kotlin中的接口</h4><p>Kotlin中的接口有部分语法与Java接口是类似的，但还是存在一些差异。下面看看上面的Java代码的Kotlin的写法。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">touch</span><span class="params">()</span></span> = println(<span class="string">"你触摸了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"点击了。。。"</span>)</span><br><span class="line">        touch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对比前面的Java代码，先主要说一下这几点差异。<br>1 . Kotlin中的默认访问修饰符是public，所以这里直接省略了<br>2 . Kotlin中也是使用<code>interface</code>关键字来声明一个接口<br>3 . Kotlin接口中的方法可以没有方法体，也可以为其提供一个默认的方法实现，就像上面的<code>touch</code>方法<br>4 . Kotlin中使用<code>:接口名</code>来实现一个接口<br>5 . Kotlin中必须在实现了接口的方法前加<code>override</code>关键字，这是强制要求，否则不能编译。在Java中的<code>@Override</code>注解是可以省略的。</p><p>通过以上对比，我们发现Kotlin中对于一些我们可能会犯错的地方做了强制要求，然后增强了接口的能力，增加了方法的默认实现功能。</p><p>上面是Kotlin中实现一个接口的例子，下面我们再来看看多个接口的复杂情况。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">()</span></span> = println(<span class="string">"我是点击开关"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Touchable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">()</span></span> = println(<span class="string">"我是触摸开关"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable</span>, <span class="type">Touchable&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Clickable&gt;.on()</span><br><span class="line">        <span class="keyword">super</span>&lt;Touchable&gt;.on()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"点击了。。。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道，如果一个类实现了两个接口，如果这两个接口中有同名的抽象方法，那我们只需要实现一个方法就可以了，反正两个方法都没有方法体。<br>但是在Kotlin中引入了抽象方法默认实现，这时候如果两个方法名相同，就像上面的<code>Clickable</code>接口和<code>Touchable</code>接口中都有<code>on</code>这个抽象方法的默认实现，这时候一个类同时实现这两个接口会怎么样呢。<br>这时候，由于Kotlin也不知道到底该使用哪种默认实现，这时候就冲突了，那就直接强制要求我们必须重写实现这个冲突的方法。<br>还有一种情况是我们可能需要在具体类中调用一下我们实现的接口中的默认实现方法，那如果方法名相同，我们怎么调用呢？<br>就像上面写的那样，我们使用<code>super&lt;接口名&gt;.方法名</code>，通过指定具体的接口名来调用指定的方法。</p><h4 id="Java实现Kotlin的接口"><a href="#Java实现Kotlin的接口" class="headerlink" title="Java实现Kotlin的接口"></a>Java实现Kotlin的接口</h4><p>说完了Kotlin中的接口，那我么就要考虑一下Java和Kotlin的互操作了，那我们在Kotlin中定义的接口如何在Java中实现呢，尤其是对于Kotlin中的抽象方法默认实现这种情况怎么处理呢？看看下面的代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Touchable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">()</span></span> = println(<span class="string">"我是触摸开关"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">()</span></span> = println(<span class="string">"我是点击开关"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Java代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaImpl</span> <span class="keyword">implements</span> <span class="title">Touchable</span>, <span class="title">Clickable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用默认的方法实现</span></span><br><span class="line">        Clickable.DefaultImpls.on(<span class="keyword">this</span>);</span><br><span class="line">        Touchable.DefaultImpls.on(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaImpl java = <span class="keyword">new</span> JavaImpl();</span><br><span class="line">        java.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，在Java中直接就要求实现冲突的默认方法。并且提供了<code>接口名.DefaultImpls.方法名(this)</code>这种调用方法允许我们调用Kotlin中定义的默认方法实现。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>通过上面的对比，我们发现Kotlin提供了更加灵活的接口使用，同时还提供了良好的与Java的互操作性，让我们可以写出更加优雅灵活的代码。</p>]]></content>
    
    <summary type="html">
    
      “今天说说Kotlin中的接口。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之扩展函数和属性</title>
    <link href="http://www.codekong.cn/2018/01/21/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.codekong.cn/2018/01/21/Kotlin系列之扩展函数和属性/</id>
    <published>2018-01-21T13:50:02.000Z</published>
    <updated>2018-07-02T11:05:50.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天，让我们聊聊Kotlin中的扩展函数和属性的话题。</p></blockquote><p>扩展函数和属性，见名知意，就是可以做到在目前已存在的类的基础上添加函数和属性，只是这些函数和属性定义在类的外部，是不是很好奇呢？那就一起来看看吧。</p><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><p>我们直接来一个例子进行分析，给String类添加一个成员函数<code>lastChar</code>，用来获取字符串的最后一个字符。先上代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> expand</span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>对，你没有看错，除了包声明，就只有一行代码，它的定义规则是这样的。<code>fun 需要扩展的类名.扩展的方法名: 扩展方法返回值 = 方法具体实现</code>。这里的<code>this</code>表示一个要扩展的类的对象，在这里就是String对象，所以它可以调用String类的所有可以访问的属性和方法。<br>接着我们就可以像调用一般的方法一样调用我们的扩展方法了，没有任何差异，就像下面这样。</p><p><strong>Kotlin中调用</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> expand.lastChar</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这是在另一个Kotlin文件中的调用代码</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Kotlin"</span>.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用前必须先导入函数，然后使用<code>字符串.扩展函数</code>调用。</p><p><strong>Java中调用</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> expand.ExpandFunKt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        System.out.println(ExpandFunKt.lastChar(<span class="string">"Kotlin"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Java中同样需要导入，只是导入的不是函数，而是以文件名创建的类名，然后像静态方法调用一般调用我们的扩展函数，将字符串作为参数传入即可。<br>当然Kotlin是一门追求简介的语言，上面的扩展函数还可以省略<code>this</code>，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>但请你注意，我们的扩展函数不允许破坏类的封装性，也就是我们在扩展时不能访问到类的私有属性和受保护的属性。<br>有时候，我们在Kotlin中导入的函数可能会重名，这时我们就可以使用<code>as</code>关键字在导入的同时为其其一个别名，调用的时候使用这个别名即可，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> expand.lastChar <span class="keyword">as</span> last</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Kotlin"</span>.last())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="扩展函数不可被重写"><a href="#扩展函数不可被重写" class="headerlink" title="扩展函数不可被重写"></a>扩展函数不可被重写</h4><p>其实你要是完全理解了上面的例子，就可以瞬间理解为什么扩展函数不可以被重写。我们看看扩展函数在Java中的调用形式，其实就是调用了一个类的静态方法，这里就涉及到一个Java的知识点，<code>静态函数不具备多态性，静态函数不可被重写</code>。我们写一个Java的例子来说明以下。</p><p><strong>Java代码</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"我是爸爸。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类继承父类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"我是儿子。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们用下面的代码测试以下<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">        father.say();</span><br><span class="line"></span><br><span class="line">        Son son = <span class="keyword">new</span> <span class="type">Son</span>();</span><br><span class="line">        son.say();</span><br><span class="line"></span><br><span class="line">        Father obj = <span class="keyword">new</span> <span class="type">Son</span>();</span><br><span class="line">        obj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是爸爸。。。</span><br><span class="line">我是儿子。。。</span><br><span class="line">我是儿子。。。</span><br></pre></td></tr></table></figure></p><p>这是Java的基础知识了，大家没什么异议吧，那我们接着吧上面的<code>say()</code>方法修改成<code>static</code>的看看，就像下面这样。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Father</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"我是爸爸。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"我是儿子。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">        father.say();</span><br><span class="line"></span><br><span class="line">        Son son = <span class="keyword">new</span> <span class="type">Son</span>();</span><br><span class="line">        son.say();</span><br><span class="line"></span><br><span class="line">        Father obj = <span class="keyword">new</span> <span class="type">Son</span>();</span><br><span class="line">        obj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先上面的测试代码不会运行出错，可能我们平时不会这样去调用静态方法，这里只是为了说明问题。<br>运行结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是爸爸。。。</span><br><span class="line">我是儿子。。。</span><br><span class="line">我是爸爸。。。</span><br></pre></td></tr></table></figure></p><p>尤其看第三个运行结果，对，这就说明了<code>静态方法不具有多态性</code>。如果再深入说以下就是普通成员变量的重写，导致的多态性是由于我们在使用<code>运行时类型去调用我们重写的方法，而静态方法的调用只是看这个对象的静态类型</code>。<br>上面的规则在Kotlin中同样适用，只是变成了扩展函数不具有多态性(其实你只要记住扩展函数在Java中调用时是被作为静态函数处理的你就能理解了)<br>下面我们再用Kotlin来重现以下上面的场景。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是爸爸。。。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="type">Father</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我是儿子。。。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码涉及到一点新的语法，首先在Kotlin中所有类默认是<code>final</code>的，是不可继承的，必须在前面添加<code>open</code>修饰符才可以被继承。其次继承不再使用<code>extends</code>关键字，而是使用<code>:</code>，同时，后面的继承类不是写类名，还要写<code>()</code>，其实这里面是一体的，这个表示构造函数，这个我们后面的内容会详细介绍。最后注意方法的重写必须在函数前面写<code>override</code>关键字。<br>测试代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> father1 = Father();</span><br><span class="line">    father1.say();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> son = Son();</span><br><span class="line">    son.say();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> obj: Father = Son();</span><br><span class="line">    obj.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是爸爸。。。</span><br><span class="line">我是儿子。。。</span><br><span class="line">我是儿子。。。</span><br></pre></td></tr></table></figure></p><p>现在我们开始扩展这两个类，给这两个类都扩展一个函数<code>sayName()</code>，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Father.<span class="title">sayName</span><span class="params">()</span></span> = println(<span class="string">"Father"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Son.<span class="title">sayName</span><span class="params">()</span></span> = println(<span class="string">"Son"</span>)</span><br></pre></td></tr></table></figure></p><p>下面我们来测试一下扩展函数是否被重写了，也就是是否具备多态性。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">val</span> obj2: Father = S<span class="literal">on</span>()</span><br><span class="line">obj2.sayName()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Father</span></span><br></pre></td></tr></table></figure></p><p>通过上面有点啰嗦的步骤，我们已经验证了扩展函数不可以被重写。<br>最后再说一点，如果一个类的成员函数和扩展函数具有相同的方法签名(也就是方法声明一致)，那么成员函数会被优先使用。</p><h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>学会了扩展函数，那么扩展属性学起来就容易一些了。我们仍然说说文章最开始的那个场景，我们为String类定义一个扩展属性<code>lastChar</code>，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span> <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>由于String是不可变的，所以我们这里扩展属性声明为<code>val</code>，同时由于我们扩展的属性<code>lastChar</code>并不能真正在类内部，所以我们没法给其赋初值和初始化，因为没有地方存储值，我们只能通过给它添加getter方法让其在被调用时返回值。<br>当然如果是为StringBuilder扩展属性我们就可以将扩展的属性声明为<code>var</code>，并为其添加getter和setter方法，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value: <span class="built_in">Char</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>你可能刚开始对这种写法有些陌生，没事，后续我们将介绍更多相关的内容。<br>下面看看在Kotlin和Java中如何调用吧。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin中调用</span></span><br><span class="line"><span class="keyword">import</span> expand.lastChar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder(<span class="string">"abc"</span>)</span><br><span class="line">    sb.lastChar = <span class="string">'M'</span></span><br><span class="line">    println(sb)</span><br><span class="line">    println(sb.lastChar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用前肯定要先导入，然后就可以像使用普通属性一样使用就可以啦。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中调用</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> expand.ExpandFunKt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"BNM"</span>);</span><br><span class="line">        ExpandFunKt.setLastChar(sb, <span class="string">'W'</span>);</span><br><span class="line">        System.out.println(ExpandFunKt.getLastChar(sb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Java中调用时，则是将写有扩展属性代码的类导入，然后在传参数时需要传入扩展的类的对象和要设置的值，像静态函数一样调用他们的geteer和setter方法。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>Kotlin的扩展函数和属性，增加代码设计的灵活性，我们可以在现有类的基础上进行扩展和修改，定制我们自己的类，这也极大地方便了Kotlin的Java的互操作。</p>]]></content>
    
    <summary type="html">
    
      “今天，让我们聊聊Kotlin中的扩展函数和属性的话题。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之顶层函数和属性</title>
    <link href="http://www.codekong.cn/2018/01/21/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.codekong.cn/2018/01/21/Kotlin系列之顶层函数和属性/</id>
    <published>2018-01-21T07:38:30.000Z</published>
    <updated>2018-07-02T11:05:50.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天一起来看看Kotlin中的顶层函数和属性。</p></blockquote><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>我们都知道，Java中，所有的代码都是依托于类而存在，我们所谓的函数作为类的方法，我们所谓的属性作为类的属性。但是在有些情况下，我们发现有些方法可能不是属于某一个特定类，有些属性也不是属于某一个特定的类。所以我们就创建了很多的Java工具类和属性的常量类，就像下面这样。</p><p><strong>Java代码</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_URL = <span class="string">"http://www.xxx.top:8080"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> joinToStr(Collection&lt;<span class="keyword">String</span>&gt; collection)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的类只是为了承载我们的静态属性和方法，作为了静态方法和属性的容器，这就是我们目前遇到的问题，一大堆无用的容器类，那让我们看看Kotlin中是如何处理这个问题的。</p><h4 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h4><p>见名知意，原来在Java中，类处于顶层，类包含属性和方法，在Kotlin中，函数站在了类的位置，我们可以直接把函数放在代码文件的顶层，让它不从属于任何类。就像下面这样，我们在一个<code>Str.kt</code>文件中写入如下的Kotlin代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToStr</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span>: String&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意，我们把它放在了util包中，这在我们厚密啊调用这个类时非常重要。<br>让我们现来看看在另一个Kotlin类中怎么调用。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util.joinToStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    joinToStr(collection = listOf(<span class="string">"123"</span>, <span class="string">"456"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到了吗？我们可以通过<code>import 包名.函数名</code>来导入我们将要使用的函数，然后就可以直接使用了，是不是超级方便。那我们再来看看在Java中如何调用上面的方法。</p><p><strong>Java代码</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.util.ArrayList;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> util.StrKt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        StrKt.joinToStr(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为在Java中，类还是必须要存在的，所以编译器将Str.kt文件里的代码放在了一个<code>StrKt</code>的类中，然后把我们定义的Kotlin的函数作为静态方法放在其中，所以在Java中是先通过mport导入这个类，然后通过<code>类名.方法名</code>来调用。</p><p>可能有时候你觉得Kotlin为你自动生成的这个类名不好，那你可以通过<code>@file:JvmName</code>注解来自定义类名，就像下面这样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">"StrUtil"</span>)</span><br><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToStr</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span>: String&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而且要注意，<code>这个注解必须放在文件的开头，包名的前面</code>。<br>在Java中导入类和调用的时候就要使用我们自定义的类名来进行操作了，就像这样。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.util.ArrayList;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> util.StrUtil;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        StrUtil.joinToStr(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="顶层属性"><a href="#顶层属性" class="headerlink" title="顶层属性"></a>顶层属性</h4><p>了解了顶层函数，下面再看看顶层属性。顶层属性也就是把属性直接放在文件顶层，不依附于类。我们可以在顶层定义的属性包括<code>var</code>变量和<code>val</code>常量，就像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package config</span><br><span class="line"></span><br><span class="line">var count = 0</span><br><span class="line"></span><br><span class="line">val REQUEST_URL = <span class="string">"http://localhost:8080/"</span></span><br><span class="line"></span><br><span class="line">const val BASE_URL = <span class="string">"http://www.xxx.top/"</span></span><br></pre></td></tr></table></figure></p><p>这里我定义了三个顶层属性，可能有些地方你还不太能看得懂，不急，我们先看看在Kotlin和Java中怎么用，然后我们再理解。</p><p>在Kotlin中使用<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config.count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用var变量</span></span><br><span class="line">    count++</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用val常量</span></span><br><span class="line">    config.REQUEST_URL</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用const val常量</span></span><br><span class="line">    config.BASE_URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会发现在Kotlin中只要导入就可以直接使用了，与顶层属性的使用是一样的。</p><p>在Java中使用<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">config</span>.ApiConfigKt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Main &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用var变量</span></span><br><span class="line">        ApiConfigKt.setCount(<span class="number">12</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(ApiConfigKt.getCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用val常量</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(ApiConfigKt.getREQUEST_URL());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用const val常量</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(ApiConfigKt.BASE_URL);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先导入是肯定的，通过类名类调用这个也和顶层函数里面的规则一致。然后你会发现Kotlin为var变量生成了get和set方法，然后为val常量生成了get方法，最后我们的const val常量则等同于Java的public static final常量，可以直接通过<code>类名.常量名</code>来调用。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>Kotlin中通过使用顶层函数和顶层属性帮助我们消除了Java中常见的静态工具类，使我们的代码更加整洁，值得一试。</p>]]></content>
    
    <summary type="html">
    
      “今天一起来看看Kotlin中的顶层函数和属性。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之命名参数和默认参数</title>
    <link href="http://www.codekong.cn/2018/01/20/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>http://www.codekong.cn/2018/01/20/Kotlin系列之命名参数和默认参数/</id>
    <published>2018-01-20T15:23:36.000Z</published>
    <updated>2018-07-02T11:05:50.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天一起来看看Kotlin的命名参数和默认参数。</p></blockquote><p>如果你学过Python，那你对这两个概念一定不陌生，那我们今天就来学习一波Kotlin中的默认参数和命名参数。</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>为了说明命名参数和默认参数出现的必要性，我们先抛出一个问题，如何打印出一个集合，并且定制它的打印形式。在Java中我们最常用的思路就是重写toString()方法或者是写一个打印集合的工具类，比如下面的Java代码。</p><p><strong>Java代码</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Main &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; mArrayList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    stringBuilder.<span class="built_in">append</span>(<span class="keyword">this</span>.<span class="built_in">get</span>(i));</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="keyword">this</span>.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                           stringBuilder.<span class="built_in">append</span>(<span class="string">";"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mArrayList.<span class="built_in">add</span>(<span class="string">"123"</span>);</span><br><span class="line">        mArrayList.<span class="built_in">add</span>(<span class="string">"456"</span>);</span><br><span class="line">        mArrayList.<span class="built_in">add</span>(<span class="string">"789"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(mArrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面我们是重写toString()方法，那我们看看在Kotlin中怎么做呢？我们先看看Kotlin中默认的打印样式。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf&lt;String&gt;(<span class="string">"123"</span>, <span class="string">"456"</span>, <span class="string">"789"</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：[123, 456, 789]</span></span><br></pre></td></tr></table></figure></p><p>我们现在就先用Kotlin来写一个定制打印集合样式的函数。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     prefix: <span class="type">String</span>, suffix: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex())&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(suffix)</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这种方法就是采用自己定义一个工具类，通过传入不同的参数来定制打印的样式。</p><h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>我们这里先来看看如何调用上面的函数，再说说存在的问题。</p><p><strong>Kotlin代码</strong><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="name">joinToString</span>(<span class="name">list</span>, <span class="string">";"</span>, <span class="string">"("</span>, <span class="string">")"</span>))</span><br></pre></td></tr></table></figure></p><p>显然这里有一个很不方便的地方，如果我们不借助于IDE的提示和查看方法定义，我们是很难看懂我们传递给函数的每个参数的具体含义，所以这个时候<code>命名参数</code>出现了。看这个名字就能知道，它是给参数命名，让我们对参数的传入和查看更加清楚，就像下面这样。</p><p><strong>Kotlin代码</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(joinToString(list, <span class="string">";"</span>, <span class="string">"("</span>, <span class="string">")"</span>))</span><br><span class="line">println(joinToString(collection = list, separator = <span class="string">";"</span>,<span class="built_in"> prefix </span>= <span class="string">"("</span>, suffix = <span class="string">")"</span>))</span><br><span class="line">println(joinToString( separator = <span class="string">";"</span>, collection = list,<span class="built_in"> prefix </span>= <span class="string">"("</span>, suffix = <span class="string">")"</span>))</span><br></pre></td></tr></table></figure></p><p>看到了吗，我们给传入的每个参数前面加了一个名称，这样是不是很直观呢，而且由于这里的参数是用命名指定的，所以参数的顺序可以和定义函数的顺序不同，上面的三种方式都是可以正确调用的。<br>但是这里有一些注意事项：</p><ol><li>如果我们已经指定了一个参数的名称，那么这个参数其后的参数也必须指定名称，不让就会造成混淆，Kotlin编译器就不能明白你的意图。</li><li>命名参数的形式只能用于Kotlin的函数，不能用于Java的函数，就像下面这样是错误的。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static void javaFun(String name)&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin代码</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//会报错[命名参数不能用于Java函数]</span></span><br><span class="line">    println(Main.javaFun(name  = <span class="string">"bingjianit"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>我们再回到文章开头的那个需求，我们希望我们使用Kotlin写的函数，可以在我们不传入分隔符是，默认使用”，”，在我们传入分隔符时使用我们传入的分隔符，也就是让我们的函数的某些参数具有默认值。其实同样的需求我们在Java中可以通过重载函数来实现，但是那会造成会出现很多个重载函数，在Kotlin中，我们可以通过默认参数来实现这个需求。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, separator: <span class="type">String</span> = <span class="string">","</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     prefix: <span class="type">String</span> = <span class="string">"["</span>, suffix: <span class="type">String</span> = <span class="string">"]"</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex())&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(suffix)</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中我们为后面三个参数指定了默认值，当我们不传入值时，使用默认值，传入值时使用我们自己的参数，我们可以像下面一样调用。</p><p><strong>Kotlin代码</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出 [123,456,789]</span></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(joinToString2(list)</span></span>)</span><br><span class="line"><span class="comment">//输出 [123;456;789]</span></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(joinToString2(list, separator = <span class="string">";"</span>)</span></span>)</span><br></pre></td></tr></table></figure></p><p>可以看出，我们这里其实是结合使用了默认参数和命名参数。</p><p>由于Kotlin与Java可以互操作，那么上面的函数在Java中怎么调用呢？由于Java中不支持默认参数，所以我们必须为函数传入每一个参数。就像下面这样：<br>我们在<code>Str.kt</code>文件中写了我们上面定义的有默认值的函数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Java中调用[必须传入全部的参数]</span></span><br><span class="line">System.out.<span class="built_in">println</span>(StrKt.joinToString2(mArrayList, <span class="string">","</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>));</span><br></pre></td></tr></table></figure></p><p>当然，如果你不想写这么繁琐，可以在Kotlin默认函数生成时添加一个@JvmOverloads注解，编译器就会自动为每个默认参数生成重载函数，就像下面这样</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, separator: <span class="type">String</span> = <span class="string">","</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      prefix: <span class="type">String</span> = <span class="string">"["</span>, suffix: <span class="type">String</span> = <span class="string">"]"</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex())&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(suffix)</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的Java重载函数如下<br><strong>Java代码</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T joinToString2(Collection&lt;T&gt; collection);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T joinToString2(Collection&lt;T&gt; collection, <span class="keyword">String</span> separator);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T joinToString2(Collection&lt;T&gt; collection, <span class="keyword">String</span> separator, <span class="keyword">String</span> prefix);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T joinToString2(Collection&lt;T&gt; collection, <span class="keyword">String</span> separator, <span class="keyword">String</span> prefix, <span class="keyword">String</span> suffix);</span><br></pre></td></tr></table></figure></p><p>这样我们在调用时就不需要传那么多参数了。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>Kotlin结合了多种语言的优秀特性，变成了一门简洁、精致的编程语言，并且还具备了和Java无缝的互操作性。</p>]]></content>
    
    <summary type="html">
    
      “今天一起来看看Kotlin的命名参数和默认参数。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列之异常</title>
    <link href="http://www.codekong.cn/2018/01/14/Kotlin%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://www.codekong.cn/2018/01/14/Kotlin系列之异常/</id>
    <published>2018-01-14T15:17:22.000Z</published>
    <updated>2018-07-02T11:05:50.249Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这一节我们说说Kotlin中的异常。</p></blockquote><h4 id="Java中的异常"><a href="#Java中的异常" class="headerlink" title="Java中的异常"></a>Java中的异常</h4><p>我们知道，在Java中，异常是一个绕不过的话题，说到异常，最先想到的就是<code>try...catch...finally</code>，在Kotlin中也是同样的，使用方式几乎是不变的，但是也有一些小小的变动。这里我们还是以往的惯例，先放Java代码，再上Kotlin代码。</p><p><strong>Java代码</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> readNumber(BufferedReader reader) throws IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">    result = Integer.<span class="built_in">parseInt</span>(<span class="built_in">line</span>);</span><br><span class="line">    reader.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码<code>readLine()</code>方法会抛出<code>IOException</code>，这是一个受检查异常，必须要显式处理，要么在方法声明上抛出，要么在内部捕获处理。其实代码里面的<code>parseInt()</code>方法也会抛出一个运行时异常，Java是不强制要求我们捕获处理运行时异常的，但这里我们为了和后面的内容配合讲解，处理一下这个异常。<br>修改后的代码是这样。</p><p><strong>Java代码</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> readNumber(<span class="keyword">BufferedReader</span> reader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = Integer.parseInt(<span class="built_in">line</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用<code>try...catch...finally</code>来改善了一下代码。在Java中，一个函数可以正常结束，也会在出现错误的时候抛出异常，方法的调用者可以捕获这个异常并处理它，如果没有被处理，异常会沿着调用栈再次抛出。</p><h4 id="Kotlin中throw作为表达式"><a href="#Kotlin中throw作为表达式" class="headerlink" title="Kotlin中throw作为表达式"></a>Kotlin中throw作为表达式</h4><p>在Kotlin中异常处理机制是相似的，但与Java中不同的是<code>throw</code>是一个表达式，可以作为另一个表达式的一部分使用。我们看看下面的代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">val</span> res = <span class="keyword">if</span> (n <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>)&#123;</span><br><span class="line">        n</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里说一下，前面的内容也说过<code>if</code>也是表达式，上面的代码，如果n的值在0-100直接则res的值初始化为n的值，如果不是，抛出一个异常，res的值不初始化。与我们以前的代码一样，与Java语言不同，抛出的异常不需要使用<code>new</code>。</p><h4 id="Kotlin中的异常"><a href="#Kotlin中的异常" class="headerlink" title="Kotlin中的异常"></a>Kotlin中的异常</h4><p>我们在开始给出了一个Java中的<code>try...catch...finally</code>的例子，这里我们再使用Kotlin代码实现一下，对比一下两者的差异。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        result = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码有几点需要注意。</p><ol><li>正如前面一直在说的，函数返回值类型是写在最后，用<code>:</code>分割。</li><li>你会发现Kotlin中不需要显式在方法声明上声明抛出的<code>IOException</code>。</li><li>变量的声明也是<code>变量名:变量类型</code>的格式。</li></ol><p>在Kotlin中不再区分受检查异常和不受检查异常。原因在于有时候比如我们的文件关闭出现错误的异常，除了看到这个异常，其实我们也做不了什么，Kotlin则直接将这种代码去掉了。<br>可能有的人还有疑问，在前面的java代码的<code>finally</code>块中有这样的的判空代码<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reader != <span class="built_in">null</span>)&#123;</span><br><span class="line">    reader.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么在Kotlin中消失了？这是因为在Kotlin中声明函数参数类型时，如果这样写<code>reader: BufferedReader</code>，表示这是一个不可空值，如果要声明为可空值可以这样写<code>reader: BufferedReader?</code>，这样就需要在close前判空了。</p><h4 id="Kotlin中的try作为表达式"><a href="#Kotlin中的try作为表达式" class="headerlink" title="Kotlin中的try作为表达式"></a>Kotlin中的try作为表达式</h4><p>前面我们说了<code>throw</code>作为表达式，其实try也是一个表达式，我们可以将<code>try</code>的值赋值给一个变量。我们继续该一下上面的代码。</p><p><strong>Kotlin代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>?&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">    result = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会发现代码又变少了，这里我们先补充一条规则才能理解上面的代码。<br>当<code>try</code>作为表达式时，如果try块执行正常，则try块中最后一个表达式就是结果，如果抛出异常进入<code>catch</code>块，则catch块中最后一个表达式的值就是结果。<br>知道了这条规则是不是上面的代码就好理解了</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>异常机制的出现是为了让我写出更加健壮的代码，在Kotlin中对Java的异常处理机制进行了一些改进和完善，让我们用更简洁的方式处理异常。</p>]]></content>
    
    <summary type="html">
    
      “这一节我们说说Kotlin中的异常。”
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.codekong.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.codekong.cn/tags/Kotlin/"/>
    
  </entry>
  
</feed>
